getgenv().prediction = 0.135 -- changeable
getgenv().fov_settings = {
    radius = 150, -- changeable
    points = 100, -- changeable
    drawings = {}, -- dont change
    old_mouse = {} -- dont change
}

getgenv().silent_aim = false -- enable silent aim
getgenv().silent_aim_prediction = false -- enable prediction for silent aim
getgenv().showfov = true -- show FOV
getgenv().fov_filled = true -- fill FOV circle
getgenv().fov_radius = 100 -- FOV circle radius
getgenv().hitchance = 80 -- chance of hitting in percentage

local userinputservice = game:GetService('UserInputService')
local players = game:GetService('Players')
local workspace = game:GetService('Workspace')

local tau = 2 * math.pi
local camera = workspace.CurrentCamera
local client = players.LocalPlayer

-- // Fov Circle \\ -- 
do 
    local function draw(obj, prop) 
        local obj = Drawing.new(obj)
        
        for i, v in pairs(prop) do 
            obj[i] = v 
        end
        
        return obj 
    end

    local fov_settings = {
        points = 100, -- number of points in the circle
        radius = 100, -- radius of the circle
        drawings = {}, -- to store the circle drawings
        old_mouse = {}, -- to store old mouse positions
    }

    fov_settings.drawings[1] = draw('Circle', {
        Color = Color3.new(1, 1, 1), -- white color
        Radius = fov_settings.radius,
        Filled = true, -- fill the circle
        Transparency = 1, -- full transparency
        Visible = getgenv().showfov and true or false, -- show FOV based on boolean
    })

    -- Update circle position
    task.spawn(function()
        while (task.wait()) do 
            local mouse_pos = userinputservice:GetMouseLocation()
            
            for _, drawing in pairs(fov_settings.drawings) do 
                drawing.Position = mouse_pos
            end
        end
    end)
end

-- // Lock \\ -- 
local function get_player_mouse()
    local dist = getgenv().fov_radius
    local player = nil 
    
    for i, v in pairs(players:GetPlayers()) do 
        if (v == client) then continue end 
        
        local char = v.Character 
        local root = char and char:FindFirstChild('HumanoidRootPart')
        
        if (char and root) then 
            local pos = camera:WorldToViewportPoint(root.Position)
            local mag = (Vector2.new(pos.x, pos.y) - userinputservice:GetMouseLocation()).magnitude
            
            if (mag < dist) then 
                dist = mag 
                player = v 
            end
        end
    end
    
    return player
end

local function anti_detect()
    local target = get_player_mouse()
    
    if (not target) then return end 
    
    local char = target.Character 
    local root = char and char:FindFirstChild('HumanoidRootPart')
    
    if (char and root) then 
        local velo = root.Velocity 
        
        if (velo.x > 50 or velo.y > 50 or velo.z > 50 or velo.x < -50 or velo.y < -50 or velo.z < -50) then 
            return true 
        end
    end
    
    return false
end

local function get_ping()
    local new_ping = (anti_detect() and getgenv().prediction * 16) or getgenv().prediction
    return new_ping
end

local function get_prediction()
    local target = get_player_mouse()
    
    if (not target) then return end 
    
    local char = target.Character 
    local root = char and char:FindFirstChild('HumanoidRootPart')
    local humanoid = char and char:FindFirstChild('Humanoid')
    
    if (char and root and humanoid) then 
        local velocity_pred = (root.Position + (root.Velocity * get_ping()))
        local movedirection_pred = (root.Position + (humanoid.MoveDirection * get_ping()))
        
        return (anti_detect() and movedirection_pred) or velocity_pred
    end
end

local index; index = hookmetamethod(game, '__index', function(self, key)
    if (self:IsA('Mouse') and key == 'Hit') then 
        local target = get_player_mouse()
        local hit_chance = math.random(1, 100)
        if hit_chance <= getgenv().hitchance then -- check hit chance
            return (target and CFrame.new(get_prediction())) or index(self, key)
        end
    end
   
    return index(self, key) 
end)
