

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({

    Title = 'Soul Hub | RH2 | soul#4466',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})


local Tabs = {

    Main = Window:AddTab('Shooting'),
    Defense = Window:AddTab('Defense'),
    Visuals = Window:AddTab('Visuals'),
    Ball = Window:AddTab('Ball'),
    Player = Window:AddTab('Player'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Ball Release')


















LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Auto Detection',
    Default = false,
    Tooltip = 'Auto Detection For Auto Time',
    Callback = function()
        
    end
})






















local box -- Declare the box variable outside the toggle callback function

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Auto Release Help',
    Default = false,
    Tooltip = 'Puts Box Around Character Indicating When To Shoot',
    Callback = function(turnOn)
        if turnOn then
            Library:Notify("Angle Math Calculations Are Slightly Off But You Get The Point | GREEN = SHOOT | RED = DONT | Shooting In Green = Higher Green %")
        end

        if turnOn then
            -- Get the local player
            local player = game.Players.LocalPlayer

            -- Create the box part
            box = Instance.new("Part")
            box.Size = Vector3.new(2, 3, 2)  -- Adjust the size as needed
            box.Transparency = 0.5  -- Adjust the transparency as needed
            box.Anchored = true
            box.CanCollide = false

            -- Attach the box to the player
            local humanoid = player.Character:WaitForChild("Humanoid")
            box.Parent = humanoid

            -- Update the box position and color every frame
            local function updateBox()
                if box and box.Parent then
                    local lookVector = humanoid.RootPart.CFrame.LookVector
                    local angle = math.acos(lookVector:Dot(workspace.CurrentCamera.CFrame.LookVector))

                    -- Check if the player is facing backward
                    local backwardAngle = math.acos(lookVector:Dot(Vector3.new(0, 0, -1)))
                    local isBackward = backwardAngle <= math.rad(45) or backwardAngle >= math.rad(315)

                    -- Check if the player is facing left or right
                    local leftAngle = math.acos(lookVector:Dot(Vector3.new(-1, 0, 0)))
                    local isLeft = leftAngle <= math.rad(45) or leftAngle >= math.rad(315)
                    local rightAngle = math.acos(lookVector:Dot(Vector3.new(1, 0, 0)))
                    local isRight = rightAngle <= math.rad(45) or rightAngle >= math.rad(315)

                    -- Set the box color based on the direction
                    if isBackward then
                        box.BrickColor = BrickColor.new(getgenv().dontshoot)  -- Set the color to bright red
                    elseif isLeft or isRight or angle <= math.rad(45) or angle >= math.rad(315) then
                        box.BrickColor = BrickColor.new(getgenv().shoot)  -- Set the color to bright green
                    else
                        box.BrickColor = BrickColor.new(getgenv().dontshoot)  -- Set the color to bright red
                    end

                    box.CFrame = humanoid.RootPart.CFrame
                end
            end

            game:GetService("RunService").RenderStepped:Connect(updateBox)
        else
            -- Code to disable the feature and delete the box
            if box and box.Parent then
                box:Destroy()
            end

            box = nil
        end
    end
})



local UserInputService = game:GetService("UserInputService")
local toggleEnabled = false

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Auto Release Debugger',
    Default = false,
    Tooltip = 'Helps Me To Debug Release Timings ETC',
    Callback = function(debug)
        toggleEnabled = debug
        if toggleEnabled then
            Library:Notify("This Probably Won't Be Helpful To You, But It Shows You Statistics | Mainly Used For Coding Purposes")
        end
    end
})

local notified = false

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.E then
        if toggleEnabled and not notified then
            local player = game.Players.LocalPlayer
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local position = humanoidRootPart.Position
                    local x = math.floor(position.X)
                    local y = math.floor(position.Y)
                    local z = math.floor(position.Z)
                    Library:Notify("Location Magnitude: x = " .. x .. ", y = " .. y .. ", z = " .. z)
                    local dataPing = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                    Library:Notify("Data Ping: " .. dataPing)

                    local velocity = humanoidRootPart.Velocity
                    local speed = velocity.magnitude
                    local direction = velocity.Unit

                    local directionString = "Moving Direction: "

                    if direction.Z > 0.5 then
                        directionString = directionString .. "Forward"
                    elseif direction.Z < -0.5 then
                        directionString = directionString .. "Backward"
                    elseif direction.X > 0.5 then
                        directionString = directionString .. "Right"
                    elseif direction.X < -0.5 then
                        directionString = directionString .. "Left"
                    else
                        directionString = directionString .. "Not Moving"
                    end

                    Library:Notify(directionString)

                    notified = true
                end
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.E then
        notified = false
    end
end)


local pingThreshold = getgenv().pingthreshold
local notificationEnabled = false -- Track the toggle state
local waitSliderValue = 1
local thresholdSliderValue = 150

local function checkPing()
    while notificationEnabled do
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
        if ping > pingThreshold then
            Library:Notify("High Ping Alert Detected | DO NOT SHOOT | : " .. ping)
        end
        wait(waitSliderValue)
    end
end

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'High Ping Notification',
    Default = false,
    Tooltip = 'Alerts If Ping High To Decide If You Should Shoot',
    Callback = function(enabled)
        notificationEnabled = enabled
        if enabled then
            spawn(checkPing)
        end
    end
})

LeftGroupBox:AddSlider('ThresholdSlider', {
    Text = 'Alert Ping Threshold',
    Default = thresholdSliderValue,
    Min = 0,
    Max = 500,
    Rounding = 0,
    Compact = false,

    Callback = function(value)
        pingThreshold = value
    end
})

LeftGroupBox:AddSlider('WaitSlider', {
    Text = 'Alert Ping Wait',
    Default = waitSliderValue,
    Min = 0,
    Max = 15,
    Rounding = 0,
    Compact = false,

    Callback = function(value)
        waitSliderValue = value
    end
})


LeftGroupBox:AddLabel('Auto Release Help Is For Beginners')


local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Auto Time')


-- Define initial values
local enabled = false -- Toggle state
local executed = false -- Flag variable to track execution

-- Function to execute the shot release action
local function executeShot()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local bar = player.Backpack.ActionValues.Power

    if not executed and bar.Value >= 64 then
        executed = true -- Set the flag to true to prevent further execution
        Players.LocalPlayer.Backpack.PlayerEvents.Shooting:FireServer(false, "Shooting", "Standing Shot")
        wait(3)
        executed = false
    end
end

-- Toggle callback function
local function toggleCallback(isEnabled)
    enabled = isEnabled
end

-- Key press event handler
local function onKeyPress(input)
    if input.KeyCode == Enum.KeyCode.E and enabled then
        executeShot()
    end
end

-- Value changed event handler
local function onValueChanged()
    if enabled and UserInputService:IsKeyDown(Enum.KeyCode.E) then
        executeShot()
    end
end

-- Add the toggle to the left group box
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Auto Release',
    Default = enabled,
    Tooltip = 'Releases For You',
    Callback = toggleCallback,
})

-- Get the necessary services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local bar = player.Backpack.ActionValues.Power

-- Connect events
UserInputService.InputBegan:Connect(onKeyPress)
bar:GetPropertyChangedSignal("Value"):Connect(onValueChanged) 



LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Meter',
    Default = false,
    Tooltip = 'Turn Meter Back On',
    Callback = function(state)

        if state then
            
           

local ohString1 = "Change Settings Request"
local ohString2 = "ShotmeterType"
local ohString3 = "Vertical Bar"

game:GetService("ReplicatedStorage").Remotes["Menu.RE"]:FireServer(ohString1, ohString2, ohString3)

        end
        end

    })


LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Disable Meter',
    Default = false,
    Tooltip = 'Higher Chance Of Greening',
    Callback = function(state)

            if state then
                
             

local ohString1 = "Change Settings Request"
local ohString2 = "ShotmeterType"
local ohString3 = "Off"

game:GetService("ReplicatedStorage").Remotes["Menu.RE"]:FireServer(ohString1, ohString2, ohString3)

            end
    end


})

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Green Triggerbot Delay',
    Default = 0.28,
    Min = 0,
    Max = 0.5,
    Rounding = 2,
    Compact = false,

    Callback = function()
    
    end
})

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {'Polynomical Equation', 'Meter Color White Detection'},
    Default = 2, 
    Multi = false, 

    Text = 'Auto Release Detection',
    Tooltip = 'Adjust Detection Method', 

    Callback = function(Value)
       
    end
})

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {'Ping / FPS', 'Manual', 'Alternative'},
    Default = 1, 
    Multi = false, 

    Text = 'Auto Release Method',
    Tooltip = 'Adjust Release Method', 

    Callback = function(Value)
       
    end
})

LeftGroupBox:AddLabel('Chose Aimbot Method')


local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Slider Aimbot')

-- Define initial values
_G.valshoot = 64 -- Default slider value
local enabled = false -- Toggle state
local executed = false -- Flag variable to track execution

-- Function to execute the shot release action
local function executeShot()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local bar = player.Backpack.ActionValues.Power

    if not executed and bar.Value >= _G.valshoot then
        executed = true -- Set the flag to true to prevent further execution
        Players.LocalPlayer.Backpack.PlayerEvents.Shooting:FireServer(false, "Shooting", "Standing Shot")
        wait(3)
        executed = false
    end
end

-- Toggle callback function
local function toggleCallback(isEnabled)
    enabled = isEnabled
end

-- Slider callback function
local function sliderCallback(value)
    _G.valshoot = value
end

-- Key press event handler
local function onKeyPress(input)
    if input.KeyCode == Enum.KeyCode.E and enabled then
        executeShot()
    end
end

-- Value changed event handler
local function onValueChanged()
    if enabled and UserInputService:IsKeyDown(Enum.KeyCode.E) then
        executeShot()
    end
end

-- Add the toggle to the left group box
LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Slider Release',
    Default = enabled,
    Tooltip = 'Releases For You',
    Callback = toggleCallback,
})

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Enable Meter',
    Default = false,
    Tooltip = 'Turn Meter Back On',
    Callback = function(state)

        if state then
            
           

local ohString1 = "Change Settings Request"
local ohString2 = "ShotmeterType"
local ohString3 = "Vertical Bar"

game:GetService("ReplicatedStorage").Remotes["Menu.RE"]:FireServer(ohString1, ohString2, ohString3)

        end
        end

    })

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Disable Meter',
    Default = false,
    Tooltip = 'Higher Chance Of Greening',
    Callback = function(state)

            if state then
                
             

local ohString1 = "Change Settings Request"
local ohString2 = "ShotmeterType"
local ohString3 = "Off"

game:GetService("ReplicatedStorage").Remotes["Menu.RE"]:FireServer(ohString1, ohString2, ohString3)

            end
    end


})


LeftGroupBox:AddInput('MyTextbox', {
    Default = 'Auto Release Timing',
    Numeric = false,
    Finished = false,
    Text = 'Type Timing | Or Use Slider',
    Tooltip = 'Type Aimbot Timing',
    Placeholder = 'TIMING',
})

Options.MyTextbox:OnChanged(function(newValue)
    local numericValue = tonumber(newValue) -- Convert the input to a number
    if numericValue then
        _G.valshoot = numericValue -- Update the timing value
    end
end)


-- Add the slider to the left group box
LeftGroupBox:AddSlider('MySlider', {
    Text = 'Slider Release Time',
    Default = _G.valshoot,
    Min = 30,
    Max = 80,
    Rounding = 2,
    Compact = false,
    Callback = sliderCallback,
})

-- Get the necessary services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local bar = player.Backpack.ActionValues.Power

-- Connect events
UserInputService.InputBegan:Connect(onKeyPress)
bar:GetPropertyChangedSignal("Value"):Connect(onValueChanged)

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Green Triggerbot Delay',
    Default = 0.28,
    Min = 0,
    Max = 0.5,
    Rounding = 2,
    Compact = false,

    Callback = function()
    
    end
})


LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {'Polynomical Equation', 'Meter Color White Detection'},
    Default = 2, 
    Multi = false, 

    Text = 'Auto Release Detection',
    Tooltip = 'Adjust Detection Method', 

    Callback = function(Value)
       
    end
})

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {'Ping / FPS', 'Manual', 'Alternative'},
    Default = 1, 
    Multi = false, 

    Text = 'Auto Release Method',
    Tooltip = 'Adjust Release Method', 

    Callback = function(Value)
       
    end
})








local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Contest Notifier')



-- Constants
local TEXT_COLOR_OPEN = Color3.fromRGB(0, 255, 0) -- Green
local TEXT_COLOR_CONTESTED = Color3.fromRGB(255, 0, 0) -- Red
local TEXT_COLOR_DEFAULT = Color3.fromRGB(255, 255, 255) -- White

local DISTANCE_THRESHOLD_OPEN = 15
local DISTANCE_THRESHOLD_SLIGHTLY_OPEN = 10
local DISTANCE_THRESHOLD_CONTESTED = 5

-- Player Character
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Text Label
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(0, 200, 0, 50)
textLabel.Position = UDim2.new(0.5, -100, 0, 20)
textLabel.BackgroundTransparency = 1
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextSize = 20
textLabel.TextColor3 = TEXT_COLOR_DEFAULT
textLabel.TextStrokeTransparency = 0.8
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.Visible = false -- Initially hidden

-- Add textLabel to a ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TextLabelScreenGui"
screenGui.Parent = game.Players.LocalPlayer.PlayerGui
textLabel.Parent = screenGui

-- Update Function
local function updateTextLabel()
    local playerToCheck = game.Players:GetPlayerFromCharacter(humanoidRootPart.Parent)
    if playerToCheck and playerToCheck ~= player then
        local distance = (humanoidRootPart.Position - playerToCheck.Character.HumanoidRootPart.Position).Magnitude
        
        if distance <= DISTANCE_THRESHOLD_CONTESTED then
            textLabel.Text = "CONTESTED"
            textLabel.TextColor3 = TEXT_COLOR_CONTESTED
        elseif distance <= DISTANCE_THRESHOLD_SLIGHTLY_OPEN then
            textLabel.Text = "SLIGHTLY OPEN"
            textLabel.TextColor3 = TEXT_COLOR_OPEN
        elseif distance <= DISTANCE_THRESHOLD_OPEN then
            textLabel.Text = "OPEN"
            textLabel.TextColor3 = TEXT_COLOR_OPEN
        else
            textLabel.Text = "NO PLAYER"
            textLabel.TextColor3 = TEXT_COLOR_CONTESTED
        end
    else
        textLabel.Text = "NO PLAYER"
        textLabel.TextColor3 = TEXT_COLOR_CONTESTED
    end
end

-- Update Text Label initially
updateTextLabel()

-- Connect to RenderStepped
game:GetService("RunService").RenderStepped:Connect(updateTextLabel)

local toggleEnabled = false

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Show Shooting Contest',
    Default = false,
    Tooltip = 'This MAY Not Be 100% Accurate, Its Just An Estimation.',
    Callback = function(Value)
        toggleEnabled = Value -- Update toggle state

        if Value then

        Library:Notify("Uses Math To Figure Out Contest Window")


        end

        if toggleEnabled then
            textLabel.Visible = true
        else
            textLabel.Visible = false
        end
    end
})

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {"Closest Player", "Holding Gaurd"},
    Default = 1, 
    Multi = false, 

    Text = 'Contest Method',
    Tooltip = 'How To Detect Contest', 

    Callback = function(Value)
       
    end
})

LeftGroupBox:AddLabel('Gives Estimated Contest %')


local RightGroupBox = Tabs.Main:AddRightGroupbox('Custom Contest Notifier Ranges')



-- Constants
local TEXT_COLOR_OPEN = Color3.fromRGB(0, 255, 0) -- Green
local TEXT_COLOR_CONTESTED = Color3.fromRGB(255, 0, 0) -- Red
local TEXT_COLOR_DEFAULT = Color3.fromRGB(255, 255, 255) -- White

local DISTANCE_THRESHOLD_OPEN = getgenv().open
local DISTANCE_THRESHOLD_SLIGHTLY_OPEN = getgenv().slightlyOpen
local DISTANCE_THRESHOLD_CONTESTED = getgenv().contested

-- Player Character
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Text Label
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(0, 200, 0, 50)
textLabel.Position = UDim2.new(0.5, -100, 0, 20)
textLabel.BackgroundTransparency = 1
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextSize = 20
textLabel.TextColor3 = TEXT_COLOR_DEFAULT
textLabel.TextStrokeTransparency = 0.8
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.Visible = false -- Initially hidden

-- Add textLabel to a ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TextLabelScreenGui"
screenGui.Parent = game.Players.LocalPlayer.PlayerGui
textLabel.Parent = screenGui

-- Update Function
local function updateTextLabel()
    local playerToCheck = game.Players:GetPlayerFromCharacter(humanoidRootPart.Parent)
    if playerToCheck and playerToCheck ~= player then
        local distance = (humanoidRootPart.Position - playerToCheck.Character.HumanoidRootPart.Position).Magnitude
        
        if distance <= DISTANCE_THRESHOLD_CONTESTED then
            textLabel.Text = "CONTESTED"
            textLabel.TextColor3 = TEXT_COLOR_CONTESTED
        elseif distance <= DISTANCE_THRESHOLD_SLIGHTLY_OPEN then
            textLabel.Text = "SLIGHTLY OPEN"
            textLabel.TextColor3 = TEXT_COLOR_OPEN
        elseif distance <= DISTANCE_THRESHOLD_OPEN then
            textLabel.Text = "OPEN"
            textLabel.TextColor3 = TEXT_COLOR_OPEN
        else
            textLabel.Text = "NO PLAYER DETECTED"
            textLabel.TextColor3 = TEXT_COLOR_CONTESTED
        end
    else
        textLabel.Text = "NO PLAYER DETECTED"
        textLabel.TextColor3 = TEXT_COLOR_CONTESTED
    end
end

-- Update Text Label initially
updateTextLabel()

-- Connect to RenderStepped
game:GetService("RunService").RenderStepped:Connect(updateTextLabel)

local toggleEnabled = false

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Custom Shooting Contest',
    Default = false,
    Tooltip = 'This MAY Not Be 100% Accurate, Its Just An Estimation.',
    Callback = function(Value)
        toggleEnabled = Value -- Update toggle state

        

        if toggleEnabled then
            Library:Notify("Select Your Custom Values Using The Sliders")
            textLabel.Visible = true
        else
            textLabel.Visible = false
        end
    end
})








RightGroupBox:AddSlider('MySlider', {
    Text = 'Open Player Range',
    Default = 15,
    Min = 0,
    Max = 30,
    Rounding = 0,
    Compact = false,

    Callback = function(OpenValue)
        getgenv().open = OpenValue
    end
})





RightGroupBox:AddSlider('MySlider', {
    Text = 'Slightly Open Player Range',
    Default = 10,
    Min = 0,
    Max = 30,
    Rounding = 0,
    Compact = false,

    Callback = function(SlightlyOpenValue)
        getgenv().slightlyOpen = SlightlyOpenValue
    end
})






RightGroupBox:AddSlider('MySlider', {
    Text = 'Contested Player Range',
    Default = 5,
    Min = 0,
    Max = 30,
    Rounding = 0,
    Compact = false,

    Callback = function(ContestedValue)

        getgenv().contested = ContestedValue
    end
})


RightGroupBox:AddDropdown('MyDropdown', {
    Values = {"Closest Player", "Holding Gaurd"},
    Default = 1, 
    Multi = false, 

    Text = 'Custom Contest Method',
    Tooltip = 'How To Detect Contest', 

    Callback = function(Value)
       
    end
})

RightGroupBox:AddLabel('Customizable Estimated Contest %')

local RightGroupBox = Tabs.Main:AddRightGroupbox('Anti Contest')

local userInputService = game:GetService("UserInputService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local holdingE = false
local toggleEnabled = false

-- Function to handle the key input
local function onKeyPress(input)
    if toggleEnabled and input.KeyCode == Enum.KeyCode.E then
        holdingE = true
        humanoid.HipHeight = getgenv().hh
    end
end

-- Function to handle the key release
local function onKeyRelease(input)
    if toggleEnabled and input.KeyCode == Enum.KeyCode.E then
        holdingE = false
        humanoid.HipHeight = 2 -- Set it back to the default value
    end
end

-- Function to handle toggle state change
local function toggleStateChanged(newState)
    toggleEnabled = newState
    if not toggleEnabled then
        holdingE = false
        humanoid.HipHeight = 2 -- Set it back to the default value
    end
end

-- Connect the key events
userInputService.InputBegan:Connect(onKeyPress)
userInputService.InputEnded:Connect(onKeyRelease)

-- Connect the toggle state change event
RightGroupBox:AddToggle('MyToggle', {
    Text = 'Anti Contest',
    Default = false,
    Tooltip = 'THIS FEATURE IS BLATANT',
    Callback = toggleStateChanged
})



RightGroupBox:AddSlider('MySlider', {
    Text = 'Anti Contest Height',
    Default = 3,
    Min = 0,
    Max = 10,
    Rounding = 0,
    Compact = false,

    Callback = function(adinross)

        getgenv().hh = adinross

    end
})

RightGroupBox:AddLabel('Very Blantant But OP')

local RightGroupBox = Tabs.Main:AddRightGroupbox('Release Help Settings')


RightGroupBox:AddLabel('Shoot Indicator'):AddColorPicker('ShootColorPicker', {
    Default = Color3.new(0, 1, 0), -- Bright green
    Title = 'Shoot Color',
    Transparency = 0,

    Callback = function(Value)
        getgenv().shoot = Value
    end
})

RightGroupBox:AddLabel('Dont Shoot Indicator'):AddColorPicker('DontShootColorPicker', {
    Default = Color3.new(1, 0, 0), -- Bright red
    Title = 'Dont Shoot Color',
    Transparency = 0,

    Callback = function(Value)
        getgenv().dontshoot = Value
    end
})

RightGroupBox:AddLabel('Select Colors For Indicators')

local RightGroupBox = Tabs.Main:AddRightGroupbox('Optimizer')



local enhancePerformance = false
local selectedLocation = "Park" -- Default location

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Enhance Performance',
    Default = false,
    Tooltip = 'Makes Performance Better',
    Callback = function(value)
        enhancePerformance = value
        if selectedLocation == "Gym" and enhancePerformance then
            -- Delete Gym parts
            game.Workspace.Gym.Building.Walls:Destroy()
            game.Workspace.Gym.Building.Roof:Destroy()
            game.Workspace.Gym.Building.Stairs:Destroy()
            game.Workspace.Gym.Building.Windows:Destroy()
            game.Workspace.Gym.Building.WallPads:Destroy()
            game.Workspace.Gym.Building.SupportBeams:Destroy()
            game.Workspace.Gym.Building.Railing:Destroy()
            game.Workspace.Gym.Building.Door:Destroy()
            game.Workspace.Gym.Building.Pillars:Destroy()
            game.Workspace.Gym.Building.Floors.UpperFloor:Destroy()
            game.Workspace.Gym["Invisible Walls"]:Destroy()
            game.Workspace.Gym.Building.GymLining:Destroy()
            game.Workspace.Gym.Building.TeamColor:Destroy()
        elseif selectedLocation == "Park" and enhancePerformance then
            -- Delete Park parts
            game.Workspace.Map.Inviswalls:Destroy()
            game.Workspace.Map["Base Park"].Benches:Destroy()
            game.Workspace.Map["Base Park"]["Billboards/Attractions"]:Destroy()
            game.Workspace.Map["Base Park"].Buildings:Destroy()
            game.Workspace.Map["Base Park"].Cans:Destroy()
            game.Workspace.Map["Base Park"].Lamps:Destroy()
            game.Workspace.Map["Base Park"]["Plant Decorations"]:Destroy()
            game.Workspace.Map["Base Park"].SecondaryBuildings:Destroy()
            game.Workspace.Map["Base Park"].StreetLights:Destroy()
            game.Workspace.Map["Base Park"]["Trees/Bushes"]:Destroy()
            game.Workspace.Map["Base Park"].Buildings:Destroy()
            game.Workspace.Map.Subway:Destroy()
            game.Workspace.Map.DisplayBoard:Destroy()
            game.Workspace.Nets:Destroy()
            game.Workspace.Map["Base Park"].Road:Destroy()
            game.Workspace.Map["Base Park"].Model:Destroy()
        end
    end
})

RightGroupBox:AddDropdown('MyDropdown', {
    Values = {"Park", "Gym", "Arcade"},
    Default = 1,
    Multi = false,
    Text = 'Select Location',
    Tooltip = 'Choose GYM or PARK or ARCADE',
    Callback = function(value)
        selectedLocation = value
        if selectedLocation == "Gym" and enhancePerformance then
            -- Delete Gym parts
            game.Workspace.Gym.Building.Walls:Destroy()
            game.Workspace.Gym.Building.Roof:Destroy()
            game.Workspace.Gym.Building.Stairs:Destroy()
            game.Workspace.Gym.Building.Windows:Destroy()
            game.Workspace.Gym.Building.WallPads:Destroy()
            game.Workspace.Gym.Building.SupportBeams:Destroy()
            game.Workspace.Gym.Building.Railing:Destroy()
            game.Workspace.Gym.Building.Door:Destroy()
            game.Workspace.Gym.Building.Pillars:Destroy()
            game.Workspace.Gym.Building.Floors.UpperFloor:Destroy()
            game.Workspace.Gym["Invisible Walls"]:Destroy()
            game.Workspace.Gym.Building.GymLining:Destroy()
            game.Workspace.Gym.Building.TeamColor:Destroy()
        elseif selectedLocation == "Park" and enhancePerformance then
            -- Delete Park parts
            game.Workspace.Map.Inviswalls:Destroy()
            game.Workspace.Map["Base Park"].Benches:Destroy()
            game.Workspace.Map["Base Park"]["Billboards/Attractions"]:Destroy()
            game.Workspace.Map["Base Park"].Buildings:Destroy()
            game.Workspace.Map["Base Park"].Cans:Destroy()
            game.Workspace.Map["Base Park"].Lamps:Destroy()
            game.Workspace.Map["Base Park"]["Plant Decorations"]:Destroy()
            game.Workspace.Map["Base Park"].SecondaryBuildings:Destroy()
            game.Workspace.Map["Base Park"].StreetLights:Destroy()
            game.Workspace.Map["Base Park"]["Trees/Bushes"]:Destroy()
            game.Workspace.Map["Base Park"].Buildings:Destroy()
            game.Workspace.Map.Subway:Destroy()
            game.Workspace.Map.DisplayBoard:Destroy()
            game.Workspace.Nets:Destroy()
            game.Workspace.Map["Base Park"].Road:Destroy()
            game.Workspace.Map["Base Park"].Model:Destroy()
                
        elseif selectedLocation == "Arcade" and enhancePerformance then

            local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Model" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)


local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Banner" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)


local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Bins" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)


local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Fern2" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)


local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Potted_Plant" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)


local mapFolder = game.Workspace.Map.Map

local function removeModels(folder)
    local models = folder:GetDescendants()
    
    for _, model in ipairs(models) do
        if model:IsA("Model") and model.Name == "Part" then
            model:Destroy()
        end
    end
end

removeModels(mapFolder)



game.Workspace.Map.Map.ArcadeMachines:Destroy()
game.Workspace.Map.Map.ArcadeWalls:Destroy()
game.Workspace.Nets:Destroy()

        end
    end
})



RightGroupBox:AddLabel('You Cannot Toggle This Off')











local LeftGroupBox = Tabs.Defense:AddLeftGroupbox('Defense Options')

local trackDistance = getgenv().TD or 50 -- Maximum tracking distance
local trackPrediction = getgenv().TP or 0.2 -- Player movement prediction factor
local trackHumanization = getgenv().TH or 0.5 -- Delay between tracking updates (in seconds)
local trackDistanceFromPlayer = getgenv().TDFP or 10 -- Distance from the player to track the nearest player

local autoGuardEnabled = false -- Variable to store auto guard toggle state
local trackConnection = nil -- Variable to store the track connection

local function getNearestPlayer()
    -- Function to get the nearest player within the specified distance
    local closestPlayer = nil
    local closestDistance = math.huge

    local function getDistanceToPlayer(player)
        local character = player.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local playerDistance = (rootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                return playerDistance
            end
        end
        return math.huge
    end

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer and player.Character and player.Team ~= game.Players.LocalPlayer.Team then
            local distance = getDistanceToPlayer(player)
            if distance < closestDistance and distance <= trackDistance then
                closestPlayer = player
                closestDistance = distance
            end
        end
    end

    return closestPlayer
end

local function trackNearestPlayer()
    -- Function to track the nearest player
    local nearestPlayer = getNearestPlayer()
    if nearestPlayer and nearestPlayer.Team ~= game.Players.LocalPlayer.Team then
        local character = game.Players.LocalPlayer.Character
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            local targetPosition = nearestPlayer.Character.HumanoidRootPart.Position + nearestPlayer.Character.HumanoidRootPart.CFrame.LookVector * trackDistanceFromPlayer
            local predictedPosition = targetPosition + (nearestPlayer.Character.HumanoidRootPart.Velocity * trackPrediction)
            character.Humanoid:MoveTo(predictedPosition)
        end
    end
end

local function toggleAutoGuard(enabled)
    -- Function to toggle auto guard
    autoGuardEnabled = enabled
    if enabled then
        trackConnection = game:GetService("RunService").Heartbeat:Connect(function()
            trackNearestPlayer()
        end)
    else
        if trackConnection then
            trackConnection:Disconnect()
        end
    end
end

local function onToggleAutoGuard()
    -- Function to handle auto guard toggle
    toggleAutoGuard(not autoGuardEnabled)
end

local autoGuardToggle = LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Auto Guard',
    Default = false,
    Tooltip = 'Auto Guards Defense For You',
    Callback = onToggleAutoGuard
})

game:GetService("UserInputService").InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.G then
        autoGuardToggle:Set(autoGuardEnabled)
        toggleAutoGuard(not autoGuardEnabled)
    end
end)

game:GetService("RunService").Heartbeat:Connect(function()
    if autoGuardEnabled then
        -- moveRandomly() -- Commented out since moveRandomly function is not defined in the provided code
    end
end)

LeftGroupBox:AddSlider('MySlider1', { -- Changed the slider name to avoid conflicts
    Text = 'Track Distance',
    Default = trackDistance,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(tdd)
        getgenv().TD = tdd
        trackDistance = tdd
    end
})



LeftGroupBox:AddSlider('MySlider2', { -- Changed the slider name to avoid conflicts
    Text = 'Track Prediction',
    Default = trackPrediction,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(tpp)
        getgenv().TP = tpp
        trackPrediction = tpp
    end
})



LeftGroupBox:AddSlider('MySlider3', { -- Changed the slider name to avoid conflicts
    Text = 'Track Humanization',
    Default = trackHumanization,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(thh)
        getgenv().TH = thh
        trackHumanization = thh
    end
})




local RightGroupBox = Tabs.Defense:AddRightGroupbox('Height Options')

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Increase Height',
    Default = false,
    Tooltip = 'Slightly increases height by raising your character up, kinda unnoticeable',
    Callback = function(Value)
        if Value then
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = 2.2
        else
            game.Players.LocalPlayer.Character.Humanoid.HipHeight = 2
        end
    end
})


local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('ESP Options')




local arrowSymbol = "🏀"
local arrowColor = Color3.new(1, 0, 0)
local maxDistance = 50
local espEnabled = false
local espStyle = ""  -- New variable to store the selected ESP style
local updateConnection

local function createESP(part)
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Adornee = part
    billboardGui.Size = UDim2.new(2, 0, 2, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.Parent = part

    local arrowLabel = Instance.new("TextLabel")
    arrowLabel.BackgroundTransparency = 1
    arrowLabel.Size = UDim2.new(1, 0, 1, 0)
    arrowLabel.Text = arrowSymbol

    -- Apply the selected ESP style
    if espStyle == "Style 1" then
        arrowLabel.TextColor3 = Color3.new(0, 1, 0) -- Example: Green color for Style 1
    elseif espStyle == "Style 2" then
        arrowLabel.Font = Enum.Font.SourceSansBold -- Example: Bold font for Style 2
    end

    arrowLabel.TextColor3 = arrowColor -- Use the default arrow color if no style is selected
    arrowLabel.TextScaled = true
    arrowLabel.Parent = billboardGui
end

local function updateESPVisibility()
    local player = game.Players.LocalPlayer
    local ballsFolder = game.Workspace:FindFirstChild("Balls")

    if not ballsFolder or not ballsFolder:IsA("Folder") then
        print("ERROR 404: REPORT TO SOUL")
        return
    end

    local descendants = ballsFolder:GetDescendants()
    for _, descendant in ipairs(descendants) do
        if descendant:IsA("BasePart") then
            local distance = (player.Character.HumanoidRootPart.Position - descendant.Position).Magnitude
            local isVisible = distance <= maxDistance

            if isVisible and not descendant:FindFirstChild("BillboardGui") then
                createESP(descendant)
            elseif not isVisible and descendant:FindFirstChild("BillboardGui") then
                descendant:FindFirstChild("BillboardGui"):Destroy()
            end
        end
    end
end

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Basketball ESP',
    Default = false,
    Tooltip = 'ESP For Basketballs',
    Callback = function(enabled)
        if enabled then
            espEnabled = true
            updateConnection = game:GetService("RunService").Heartbeat:Connect(updateESPVisibility)
        else
            espEnabled = false
            if updateConnection then
                updateConnection:Disconnect()
                updateConnection = nil
            end
            local ballsFolder = game.Workspace:FindFirstChild("Balls")
            if ballsFolder and ballsFolder:IsA("Folder") then
                for _, descendant in ipairs(ballsFolder:GetDescendants()) do
                    if descendant:IsA("BasePart") and descendant:FindFirstChild("BillboardGui") then
                        descendant:FindFirstChild("BillboardGui"):Destroy()
                    end
                end
            end
        end
    end
})

LeftGroupBox:AddSlider('MySlider', {
    Text = 'Basketball Max Distance',
    Default = 50,
    Min = 0,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Callback = function(distance)
        maxDistance = distance
        if espEnabled then
            updateESPVisibility()
        end
    end
})

local espStyles = {
    "Default",
    "UPDATING",
    "NOT OUT"
}

LeftGroupBox:AddDropdown('MyDropdown', {
    Values = espStyles,
    Default = 1,
    Multi = false,
    Text = 'Basketball ESP Style',
    Tooltip = 'Choose ESP Style',
    Callback = function(value)
        espStyle = espStyles[value]
        if espEnabled then
            updateESPVisibility()
        end
    end
})












--------------


local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('ESP Cham Options')



local chamsColor = Color3.new(1, 0, 0) -- Chams color
local maxDistance = 50
local espEnabled = false
local updateConnection

local function createESP(part, color)
    local chams = Instance.new("BoxHandleAdornment")
    chams.Adornee = part
    chams.AlwaysOnTop = true
    chams.ZIndex = 5
    chams.Size = part.Size
    chams.Transparency = 0.5
    chams.Color3 = color
    chams.Name = "BoxHandleAdornment"
    chams.Parent = part
end

local function updateESPVisibility()
    local player = game.Players.LocalPlayer
    local ballsFolder = game.Workspace:FindFirstChild("Balls")

    if not ballsFolder or not ballsFolder:IsA("Folder") then
        print("ERROR 404: REPORT TO SOUL")
        return
    end

    local descendants = ballsFolder:GetDescendants()
    for _, descendant in ipairs(descendants) do
        if descendant:IsA("BasePart") then
            local distance = (player.Character.HumanoidRootPart.Position - descendant.Position).Magnitude
            local isVisible = distance <= maxDistance

            if isVisible and not descendant:FindFirstChild("BoxHandleAdornment") then
                createESP(descendant, chamsColor)
            elseif not isVisible and descendant:FindFirstChild("BoxHandleAdornment") then
                descendant:FindFirstChild("BoxHandleAdornment"):Destroy()
            end
        end
    end
end

LeftGroupBox:AddToggle('BasketballChamsToggle', {
    Text = 'Basketball Chams',
    Default = false,
    Tooltip = 'Chams for Basketballs',
    Callback = function(enabled)
        if enabled then
            espEnabled = true
            updateConnection = game:GetService("RunService").Heartbeat:Connect(updateESPVisibility)
        else
            espEnabled = false
            if updateConnection then
                updateConnection:Disconnect()
                updateConnection = nil
            end
            local ballsFolder = game.Workspace:FindFirstChild("Balls")
            if ballsFolder and ballsFolder:IsA("Folder") then
                for _, descendant in ipairs(ballsFolder:GetDescendants()) do
                    if descendant:IsA("BasePart") and descendant:FindFirstChild("BoxHandleAdornment") then
                        descendant:FindFirstChild("BoxHandleAdornment"):Destroy()
                    end
                end
            end
        end
    end
})

LeftGroupBox:AddSlider('BasketballChamsSlider', {
    Text = 'Basketball Max Distance',
    Default = 50,
    Min = 0,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Callback = function(distance)
        maxDistance = distance
        if espEnabled then
            updateESPVisibility()
        end
    end
})

local colorPicker = LeftGroupBox:AddLabel('Basketball Cham Color'):AddColorPicker('ShootColorPicker', {
    Default = chamsColor,
    Title = 'Basketball Cham Color',
    Transparency = 0,

    Callback = function(value)
        chamsColor = value
        if espEnabled then
            local ballsFolder = game.Workspace:FindFirstChild("Balls")
            if ballsFolder and ballsFolder:IsA("Folder") then
                for _, descendant in ipairs(ballsFolder:GetDescendants()) do
                    if descendant:IsA("BasePart") and descendant:FindFirstChild("BoxHandleAdornment") then
                        descendant:FindFirstChild("BoxHandleAdornment").Color3 = chamsColor
                    end
                end
            end
        end
    end
})


LeftGroupBox:AddDropdown('MyDropdown', {
    Values = {'Default', 'UPDATING'},
    Default = 1, 
    Multi = false, 

    Text = 'Basketball Cham ESP Style',
    Tooltip = 'Choose Cham ESP Style', 

    Callback = function(Value)
       
    end
})







-----------------



local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Open Options')




-- Constants
local NOTIFY_DISTANCE = 30 -- Distance threshold for wide open players
local TEAMMATE_PROXIMITY = 5 -- Distance threshold for checking teammates

-- Function to check if a player is wide open
local function isPlayerWideOpen(player)
    local players = game.Players:GetPlayers()
    local currentPlayer = game.Players.LocalPlayer

    -- Check if player is on the same team
    if player.Team ~= currentPlayer.Team then
        return false
    end

    -- Check if there are any players within teammate proximity
    for _, otherPlayer in ipairs(players) do
        if otherPlayer ~= currentPlayer and otherPlayer ~= player then
            local distance = (otherPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance <= TEAMMATE_PROXIMITY then
                return false
            end
        end
    end

    return true
end

-- Function to notify about wide open teammates
local function notifyWideOpenTeammates()
    local players = game.Players:GetPlayers()
    local currentPlayer = game.Players.LocalPlayer

    local teammateNumber = 1
    local notifyCount = 0

    for _, player in ipairs(players) do
        if player ~= currentPlayer then
            local distance = (player.Character.HumanoidRootPart.Position - currentPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance <= NOTIFY_DISTANCE and isPlayerWideOpen(player) then
                local closestPlayerToTeammate
                local closestDistance = math.huge

                -- Find the closest player to the wide open teammate
                for _, otherPlayer in ipairs(players) do
                    if otherPlayer ~= currentPlayer and otherPlayer.Team == currentPlayer.Team then
                        local otherDistance = (otherPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                        if otherDistance < closestDistance then
                            closestPlayerToTeammate = otherPlayer
                            closestDistance = otherDistance
                        end
                    end
                end

                -- Notify about the wide open teammate
                local message = string.format("Alert: Open Teammate - Name: %s, Teammate Number: %d, Closest Player to Them: %s, Studs: %.2f",
                    player.Name, teammateNumber, closestPlayerToTeammate.Name, closestDistance)
                Library:Notify(message)
                notifyCount = notifyCount + 1

                teammateNumber = teammateNumber + 1
            end
        end
    end

    -- Wait for the number of notifications sent
    wait(notifyCount * 0) -- Adjust the wait time as desired
end


local isNotifyEnabled = false -- Variable to track the toggle state
local notifyLoopId -- Variable to store the notification loop connection

-- Callback function for the toggle
local function toggleCallback(enabled)
    isNotifyEnabled = enabled

    if enabled then
        -- Start the notification loop
        notifyLoopId = game:GetService("RunService").Heartbeat:Connect(function()
            notifyWideOpenTeammates()
        end)
    else
        -- Disconnect the notification loop
        if notifyLoopId then
            notifyLoopId:Disconnect()
            notifyLoopId = nil
        end
    end
end

-- AddToggle function
LeftGroupBox:AddToggle('BasketballChamsToggle', {
    Text = 'Open Teammate Notify',
    Default = false,
    Tooltip = 'Notifies If Teammate Is Open',
    Callback = toggleCallback,
})



local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('Mod Options')



LeftGroupBox:AddToggle('BasketballChamsToggle', {
    Text = 'Mod Alert',
    Default = false,
    Tooltip = 'Alerts If A Mod Joins',
    Callback = modCallback,
})


LeftGroupBox:AddToggle('BasketballChamsToggle', {
    Text = 'Kick On Mod Alert',
    Default = false,
    Tooltip = 'Kicks You If A Mod Joins',
    Callback = modCallback,
})





local LeftGroupBox = Tabs.Ball:AddLeftGroupbox('Ball Settings')


LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Ball Magnet',
    Default = false,
    Tooltip = 'Gives You Extra Reach On Ball',
    Callback = function(Value)
        if Value then

        Library:Notify("Make Sure You Adjust Magnet Strength Using The Slider | Small Magnet But Makes Huge Difference")

        end
    end
    
})


LeftGroupBox:AddSlider('MySlider', {
    Text = 'Magnet Amount',
    Default = 1,
    Min = 0,
    Max = 5,
    Rounding = 0,
    Compact = false,
    Callback = function(wss)


    end
    
})


LeftGroupBox:AddLabel('Extra Reach On Ball')

local LeftGroupBox = Tabs.Ball:AddLeftGroupbox('Ball Size')

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Original Ball Size',
    Default = false,
    Tooltip = 'Change Size Of Ball',
    Callback = function(Value)
        if Value then
            Library:Notify("Original Ball Size Set | DISCLAIMER: Putting Ball Size Slider TOO HIGH Could Glitch Balls")
            local multiplier = 0.7
            for _, part in pairs(game:GetDescendants()) do
                if part:IsA("BasePart") and part.Name == "Ball" then
                    part.Size = part.Size * multiplier
                end
            end
        end
    end
})

local walkSpeedSlider = LeftGroupBox:AddSlider('MySlider', {
    Text = 'Ball Size Amount',
    Default = 0.7,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(wss)
        local multiplier = wss
        for _, part in pairs(game:GetDescendants()) do
            if part:IsA("BasePart") and part.Name == "Ball" then
                part.Size = part.Size * multiplier
            end
        end
    end
})



LeftGroupBox:AddLabel('Expand Ball Size')




local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Player Settings')

local mt = getrawmetatable(game)
make_writeable(mt)
local old_index = mt.__index
local infiniteStaminaEnabled = false

mt.__index = newcclosure(function(a, b)
    if infiniteStaminaEnabled and tostring(a) == "Stamina" and tostring(b) == "Value" then
        return math.huge
    end
    return old_index(a, b)
end)

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Infinite Stamina',
    Default = false,
    Tooltip = 'Gives You Infinite Stamina',
    Callback = function(enabled)
        if enabled then
            Library:Notify("Gives You Infinite Stamina Which You Can Run Forever | However There Is Still Shot Fatigue")
        end    
        infiniteStaminaEnabled = enabled
    end
})

LeftGroupBox:AddLabel('Still Get Shot Fatigue')

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Boost Options')

local isSliderEnabled = false
local originalWalkSpeed

local player = game.Players.LocalPlayer
local character = player.Character
local humanoid = character:FindFirstChildOfClass("Humanoid")

if humanoid then
    originalWalkSpeed = humanoid.WalkSpeed

    local toggleButton = LeftGroupBox:AddToggle('MyToggle', {
        Text = 'Speed Boost',
        Default = false,
        Tooltip = 'Enable Speed Boost',
        Callback = function(toggleState)

            if toggleState then
                
                Library:Notify("If Your Changes Are Not Being Changing Toggle It Off Then ReToggle It On!")
                Library:Notify("Be CAREFUL! Putting This To High Is Blantant!")

            end

            isSliderEnabled = toggleState
            if not isSliderEnabled then
                humanoid.WalkSpeed = originalWalkSpeed
            end
        end
    })

    local walkSpeedSlider = LeftGroupBox:AddSlider('MySlider', {
        Text = 'Walkspeed Boost',
        Default = 0.5,
        Min = 0,
        Max = 0.89,
        Rounding = 2,
        Compact = false,
        Callback = function(ws)
            if isSliderEnabled then
                while isSliderEnabled do
                    wait(0.01)
                    local walkSpeed = originalWalkSpeed + (ws * (originalWalkSpeed / 2)) -- Scale the slider value to a desired walk speed range
                    humanoid.WalkSpeed = walkSpeed
                end
            end
        end
    })
end









LeftGroupBox:AddLabel('Change Humanoid Speed')




local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Spin Bot')


LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Infinite Stamina',
    Default = false,
    Tooltip = 'Gives You Infinite Stamina',
    Callback = function(enabled)
        if enabled then
            Library:Notify("Gives You Infinite Stamina Which You Can Run Forever | However There Is Still Shot Fatigue")
        end    
        infiniteStaminaEnabled = enabled
    end
})

LeftGroupBox:AddLabel('Still Get Shot Fatigue')

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local spinEnabled = false
local spinSpeed = 5

local function spinPlayer()
    local startRotation = character.HumanoidRootPart.Orientation

    while spinEnabled do
        character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        wait()
    end
end

local enableToggle = LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Spin',
    Default = false,
    Tooltip = 'Enable Spin Control Amount With Slider',
    Callback = function(spin)

        if spin then

            Library:Notify("Putting This To High Could Mess With Aimbot As Well As Auto Release Help")

        end

        spinEnabled = spin
        if spinEnabled then
            spinPlayer()
        end
    end
})

local spinAmountSlider = LeftGroupBox:AddSlider('MySlider', {
    Text = 'Spin Amount',
    Default = 5,
    Min = 0,
    Max = 50,
    Rounding = 0,
    Compact = false,
    Callback = function(amount)
        spinSpeed = amount
    end
})

LeftGroupBox:AddLabel('Just Spins Character')


local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Visualizer')


local root = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart

local trail = Instance.new("Trail")
for k, v in pairs({
    Lifetime = 3,
    MaxLength = 9e9,
    MinLength = 0,
    FaceCamera = true,
    Enabled = false,
    Attachment0 = root:FindFirstChildOfClass("Attachment"),
    Attachment1 = root.Parent.Head:FindFirstChildOfClass("Attachment"),
    Parent = root,
    Color = ColorSequence.new(Color3.fromRGB(128, 0, 128)) -- Set the trail color to purple
}) do
    trail[k] = v
end

-- Set the WidthScale property of the trail with a NumberSequence
trail.WidthScale = NumberSequence.new(0.5)

-- Function to toggle the trail
local function toggleTrail()
    trail.Enabled = not trail.Enabled
end

local enableToggle = LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Trail',
    Default = false,
    Tooltip = 'Gives Cool Trail :)',
    Callback = toggleTrail
})

local trailAmountSlider = LeftGroupBox:AddSlider('MySlider', {
    Text = 'Trail Lifetime',
    Default = 3,
    Min = 0,
    Max = 20,
    Rounding = 0,
    Compact = false,
    Callback = function(amount)
        trail.Lifetime = amount
    end
})

local colorPicker = LeftGroupBox:AddLabel('Trail Color'):AddColorPicker('ShootColorPicker', {
    Default = Color3.new(0, 1, 0), -- purple
    Title = 'Trail Color',
    Transparency = 0,

    Callback = function(value)
        trail.Color = ColorSequence.new(value)
    end
})


LeftGroupBox:AddLabel('Just Gives You A Trail')

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Fake Lag')

local enableToggle = LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Lag',
    Default = false,
    Tooltip = 'Enable The Fake Lag',
    Callback = function(enabled)
        if enabled then
            settings().Network.IncommingReplicationLag = getgenv().lags
        else
            settings().Network.IncommingReplicationLag = 0
        end
    end
})

local trailAmountSlider = LeftGroupBox:AddSlider('MySlider', {
    Text = 'Lag Strength',
    Default = 100,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(amount)
            getgenv().lags = amount
    end
})

LeftGroupBox:AddLabel('Replicates Fake Lag')

local RightGroupBox = Tabs.Player:AddRightGroupbox('Field Of View')




local enableToggle = RightGroupBox:AddToggle('MyToggle', {
    Text = 'FOV',
    Default = false,
    Tooltip = 'Enable The FOV',
    Callback = function(enabled)

        if enabled then

            Library:Notify("There Is A Chance This Could Mess With Auto Release")

        end

        -- Callback function for toggle
        if enabled then
            EnableFOV()
        else
            DisableFOV()
        end
    end
})

local trailAmountSlider = RightGroupBox:AddSlider('MySlider', {
    Text = 'FOV Amount',
    Default = 70,
    Min = 70,
    Max = 120,
    Rounding = 0,
    Compact = false,
    Callback = function(amount)
        -- Callback function for slider
        SetFOVAmount(amount)
    end
})

local fovAmount = 70
local defaultFOV = 70 -- Set this to the default FOV value when FOV is disabled
local updateInterval = 0.001 -- Adjust this value to control the update interval in seconds

local fovUpdateConnection = nil

-- Enable FOV
function EnableFOV()
    -- Code to enable the FOV
    if not fovUpdateConnection then
        fovUpdateConnection = game:GetService('RunService').RenderStepped:Connect(UpdateFOV)
    end
end

-- Disable FOV
function DisableFOV()
    -- Code to disable the FOV
    if fovUpdateConnection then
        fovUpdateConnection:Disconnect()
        fovUpdateConnection = nil
    end
    game:GetService('Workspace').Camera.FieldOfView = defaultFOV
end

-- Set FOV Amount
function SetFOVAmount(amount)
    -- Code to set the FOV amount
    fovAmount = amount
    if enableToggle:GetValue() then
        game:GetService('Workspace').Camera.FieldOfView = fovAmount
    end
end

-- Update FOV
function UpdateFOV()
    game:GetService('Workspace').Camera.FieldOfView = fovAmount
end

RightGroupBox:AddLabel('Unlock Camera FOV')

local RightGroupBox = Tabs.Player:AddRightGroupbox('Zoom Settings')

local enableToggle = RightGroupBox:AddToggle('MyToggle', {
    Text = 'Zoom',
    Default = false,
    Tooltip = 'Enable Zoom',
    Callback = function(enabled)
        -- Callback function for toggle
        if enabled then
            EnableZoom()
        else
            DisableZoom()
        end
    end
})

local zoomAmountSlider = RightGroupBox:AddSlider('MySlider', {
    Text = 'Zoom Amount',
    Default = 10,
    Min = 1,
    Max = 200,
    Rounding = 0,
    Compact = false,
    Callback = function(amount)
        -- Callback function for slider
        SetZoomAmount(amount)
    end
})

local zoomAmount = 10
local defaultZoom = 10 -- Set this to the default zoom value when zoom is disabled

local zoomUpdateConnection = nil

-- Enable Zoom
function EnableZoom()
    -- Code to enable zoom
    if not zoomUpdateConnection then
        zoomUpdateConnection = game:GetService('RunService').RenderStepped:Connect(UpdateZoom)
    end
end

-- Disable Zoom
function DisableZoom()
    -- Code to disable zoom
    if zoomUpdateConnection then
        zoomUpdateConnection:Disconnect()
        zoomUpdateConnection = nil
    end
    game.Players.LocalPlayer.CameraMaxZoomDistance = defaultZoom
end

-- Set Zoom Amount
function SetZoomAmount(amount)
    -- Code to set the zoom amount
    zoomAmount = amount
    if enableToggle:GetValue() then
        game.Players.LocalPlayer.CameraMaxZoomDistance = zoomAmount
    end
end

-- Update Zoom
function UpdateZoom()
    game.Players.LocalPlayer.CameraMaxZoomDistance = zoomAmount
end


RightGroupBox:AddLabel('Unlock Camera Zoom')



local RightGroupBox = Tabs.Player:AddRightGroupbox('Dribble Macros')

local dribbleMacroEnabled = false

local enableToggle = RightGroupBox:AddToggle('MyToggle', {
    Text = 'Activate',
    Default = false,
    Tooltip = 'Activate The Dribble Macros',
    Callback = function(enabled)

        if enabled then

            Library:Notify("You Still Must Have Dribble Requirement To Do The Move")

        end    

        dribbleMacroEnabled = enabled
    end
})

local function dribbleCallback(ohString1)
    if dribbleMacroEnabled then
        local ohInstance2 = workspace.Goals.Goal1
        game:GetService("Players").LocalPlayer.Backpack.PlayerEvents.Dribbling:FireServer(ohString1, ohInstance2)
    end
end

RightGroupBox:AddLabel('2x Behind Back Left'):AddKeyPicker('KeyPicker1', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("XZ")
    end
})

RightGroupBox:AddLabel('2x Behind Back Right'):AddKeyPicker('KeyPicker2', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("XC")
    end
})

RightGroupBox:AddLabel('Snatchback Left'):AddKeyPicker('KeyPicker3', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("XZ")
    end
})

RightGroupBox:AddLabel('Snatchback Right'):AddKeyPicker('KeyPicker4', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("XC")
    end
})

RightGroupBox:AddLabel('Half Spin Left'):AddKeyPicker('KeyPicker5', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("ZZ")
    end
})

RightGroupBox:AddLabel('Half Spin Right'):AddKeyPicker('KeyPicker6', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        dribbleCallback("CC")
    end
})



    









local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()

SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')


SaveManager:BuildConfigSection(Tabs['UI Settings'])

ThemeManager:ApplyToTab(Tabs['UI Settings'])


SaveManager:LoadAutoloadConfig()


