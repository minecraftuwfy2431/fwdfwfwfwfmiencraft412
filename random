local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local a = mainPage:Section({Name = "Movement"})

local character = plr.Character or plr.CharacterAdded:Wait()
local humanoid = character:FindFirstChildWhichIsA("Humanoid")
local hrp = character:FindFirstChild("HumanoidRootPart")

local walkSpeedEnabled = false
local speed = 0.072
local movementKeys = {
    [Enum.KeyCode.W] = false,
    [Enum.KeyCode.A] = false,
    [Enum.KeyCode.S] = false,
    [Enum.KeyCode.D] = false,
}
local movementKeysPressed = false
local movementConn

UserInputService.InputBegan:Connect(function(input)
    if movementKeys[input.KeyCode] ~= nil then
        movementKeys[input.KeyCode] = true
        movementKeysPressed = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if movementKeys[input.KeyCode] ~= nil then
        movementKeys[input.KeyCode] = false
        movementKeysPressed = movementKeys[Enum.KeyCode.W]
            or movementKeys[Enum.KeyCode.A]
            or movementKeys[Enum.KeyCode.S]
            or movementKeys[Enum.KeyCode.D]
    end
end)

a:Toggle({
    Name = "Walk Speed",
    Flag = "WalkSpeedToggle",
    Risky = true,
    Callback = function(enabled)
        walkSpeedEnabled = enabled
        if movementConn then movementConn:Disconnect() movementConn = nil end
        if enabled then
            movementConn = RunService.Heartbeat:Connect(function()
                if movementKeysPressed and humanoid and humanoid.MoveDirection.Magnitude > 0 then
                    hrp.CFrame = hrp.CFrame + humanoid.MoveDirection.Unit * speed
                end
            end)
        end
    end,
}):Keybind({Name = "Walk Speed Keybind", Flag = "WalkSpeedKeybind", Mode = "Toggle"})

a:Slider({
    Name = "Current Speed",
    Flag = "WalkSpeedSlider",
    Min = 0,
    Max = 1,
    Default = speed,
    Decimals = 0.001,
    Callback = function(value) speed = value end,
})

plr.CharacterAdded:Connect(function(newChar)
    character = newChar
    humanoid = newChar:WaitForChild("Humanoid")
    hrp = newChar:WaitForChild("HumanoidRootPart")
end)

local flyspeed = 17
local flying = false
local flyKeys = {}
local flyCharConn

local function GetVelocity(origin, target, speed)
    return (target - origin).Unit * speed
end

local function getKeyName(keyCode)
    local str = tostring(keyCode):lower()
    local _, i = str:find("keycode%.")
    return str:sub(i + 1)
end

local function setupCamera(char)
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum then
        UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        hum.CameraOffset = Vector3.new(2, 0, 0)
    end
end

a:Toggle({
    Name = "Fly",
    Risky = true,
    Flag = "FlyToggle",
    Callback = function(enabled)
        flying = enabled
        if enabled then
            if plr.Character then setupCamera(plr.Character) end
            flyCharConn = plr.CharacterAdded:Connect(setupCamera)
        else
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
            if flyCharConn then flyCharConn:Disconnect(); flyCharConn = nil end
            if hrp then hrp.Velocity = Vector3.new(); hrp.Anchored = false end
        end
    end,
}):Keybind({Name = "Fly Keybind", Flag = "FlyKeybind", Mode = "Toggle"})

a:Slider({
    Name = "Fly Speed",
    Flag = "FlySpeed",
    Min = 0,
    Max = 350,
    Default = flyspeed,
    Callback = function(value) flyspeed = value end,
})

RunService.Heartbeat:Connect(function()
    if not flying or not hrp then return end
    local pos = hrp.Position
    local cf = hrp.CFrame
    local vel = Vector3.new()
    if flyKeys.w then vel += GetVelocity(pos, (cf * CFrame.new(0,0,-1e4)).Position, flyspeed) end
    if flyKeys.s then vel += GetVelocity(pos, (cf * CFrame.new(0,0,1e4)).Position, flyspeed) end
    if flyKeys.a then vel += GetVelocity(pos, (cf * CFrame.new(-1e4,0,0)).Position, flyspeed) end
    if flyKeys.d then vel += GetVelocity(pos, (cf * CFrame.new(1e4,0,0)).Position, flyspeed) end
    if flyKeys.e or flyKeys.space then vel += Vector3.new(0, flyspeed, 0) end
    if flyKeys.q then vel += Vector3.new(0, -flyspeed, 0) end
    hrp.Velocity = vel
    hrp.CFrame = CFrame.new(pos, pos + workspace.CurrentCamera.CFrame.LookVector)
    hrp.Anchored = vel.Magnitude == 0
end)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    local key = getKeyName(input.KeyCode)
    flyKeys[key] = true
end)

UserInputService.InputEnded:Connect(function(input)
    local key = getKeyName(input.KeyCode)
    flyKeys[key] = false
end)

local infiniteJumpEnabled = false

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled and humanoid then humanoid:ChangeState("Jumping") end
end)

a:Toggle({
    Name = "Infinite Jump",
    Risky = true,
    Flag = "InfiniteJumpToggle",
    Callback = function(enabled) infiniteJumpEnabled = enabled end,
}):Keybind({Name = "Infinite Jump Keybind", Flag = "InfiniteJumpKeybind", Mode = "Toggle"})

local noclipConn

a:Toggle({
    Name = "Noclip",
    Risky = true,
    Flag = "NoclipToggle",
    Callback = function(enabled)
        if noclipConn then noclipConn:Disconnect(); noclipConn = nil end
        if enabled then
            noclipConn = RunService.Stepped:Connect(function()
                if plr.Character then
                    for _, part in pairs(plr.Character:GetDescendants()) do
                        if part:IsA("BasePart") then part.CanCollide = false end
                    end
                end
            end)
        else
            if plr.Character then
                for _, part in pairs(plr.Character:GetDescendants()) do
                    if part:IsA("BasePart") then part.CanCollide = true end
                end
            end
        end
    end,
}):Keybind({Name = "Noclip Keybind", Flag = "NoclipKeybind", Mode = "Toggle"})

local originalGravity = workspace.Gravity
local gravityValue = originalGravity

a:Toggle({
    Name = "Gravity",
    Flag = "GravityToggle",
    Risky = true,
    Callback = function(v) workspace.Gravity = v and gravityValue or originalGravity end,
}):Keybind({Name = "Gravity Keybind", Flag = "GravityKeybind", Mode = "Toggle"})

a:Slider({
    Name = "Current Gravity",
    Flag = "GravitySlider",
    Min = 0,
    Max = 500,
    Default = gravityValue,
    Callback = function(g) gravityValue = g; workspace.Gravity = g end,
})

local quickTeleportEnabled = false
local quickTPDistance = 10

a:Toggle({
    Name = "Quick Teleport",
    Flag = "QuickTeleportToggle",
    Callback = function(state) quickTeleportEnabled = state end,
}):Keybind({Name = "Quick Teleport Keybind", Flag = "QuickTeleportKeybind", Mode = "Toggle"})

a:Slider({
    Name = "Quick TP Distance",
    Flag = "QuickTPDistanceSlider",
    Min = 0,
    Max = 100,
    Default = quickTPDistance,
    Callback = function(v) quickTPDistance = v end,
})

RunService.RenderStepped:Connect(function()
    if quickTeleportEnabled and movementKeysPressed and humanoid and humanoid.MoveDirection.Magnitude > 0 then
        hrp.CFrame = hrp.CFrame + humanoid.MoveDirection.Unit * quickTPDistance
    end
end)

local originalHipHeight = humanoid.HipHeight
local hipHeight = originalHipHeight
local hipEnabled = false

a:Toggle({
    Name = "Hipheight",
    Flag = "HipheightToggle",
    Risky = true,
    Callback = function(state) hipEnabled = state; humanoid.HipHeight = state and hipHeight or originalHipHeight end,
})

a:Slider({
    Name = "Hipheight Amount",
    Flag = "HipheightSlider",
    Min = 0,
    Max = 200,
    Default = hipHeight,
    Callback = function(value) hipHeight = value; if hipEnabled then humanoid.HipHeight = value end end,
})

local movementTextEnabled = false
local textOffsetX = 0
local textOffsetY = 50
local movementText = Drawing.new("Text")
movementText.Size = 20
movementText.Color = Color3.new(1,1,0)
movementText.Center = true
movementText.Visible = false

local autoDisableEnabled = false

a:Toggle({
    Name = "Movement Text",
    Flag = "MovementTextToggle",
    Callback = function(state) movementTextEnabled = state end,
})

a:Slider({
    Name = "Text Offset X",
    Flag = "TextOffsetX",
    Min = -500,
    Max = 500,
    Default = textOffsetX,
    Callback = function(value) textOffsetX = value end,
})

a:Slider({
    Name = "Text Offset Y",
    Flag = "TextOffsetY",
    Min = 0,
    Max = 500,
    Default = textOffsetY,
    Callback = function(value) textOffsetY = value end,
})

a:Toggle({
    Name = "Auto Disable All",
    Flag = "AutoDisableToggle",
    Callback = function(state) autoDisableEnabled = state end,
}):Keybind({Name = "Auto Disable Keybind", Flag = "AutoDisableKeybind", Mode = "Toggle"})

RunService.RenderStepped:Connect(function()
    if movementTextEnabled then
        local vs = workspace.CurrentCamera.ViewportSize
        movementText.Position = Vector2.new(vs.X/2 + textOffsetX, vs.Y - textOffsetY)
        local features = {}
        if walkSpeedEnabled then table.insert(features, "WalkSpeed") end
        if flying then table.insert(features, "Fly") end
        if infiniteJumpEnabled then table.insert(features, "InfiniteJump") end
        if noclipConn then table.insert(features, "Noclip") end
        if hipEnabled then table.insert(features, "Hipheight") end
        if quickTeleportEnabled then table.insert(features, "QuickTP:"..quickTPDistance) end
        movementText.Text = table.concat(features, " | ")
        movementText.Visible = true
    else
        movementText.Visible = false
    end
    if autoDisableEnabled then
        if walkSpeedEnabled then walkSpeedEnabled = false; if movementConn then movementConn:Disconnect(); movementConn = nil end end
        if flying then flying = false; if flyCharConn then flyCharConn:Disconnect(); flyCharConn = nil end; UserInputService.MouseBehavior = Enum.MouseBehavior.Default; if hrp then hrp.Velocity = Vector3.new(); hrp.Anchored = false end end
        if infiniteJumpEnabled then infiniteJumpEnabled = false end
        if noclipConn then noclipConn:Disconnect(); noclipConn = nil end
    end
end)

local abc = mainPage:Section({Name = "Camera & Misc"})
local camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")

local originalFOV = camera.FieldOfView
local fovScale = originalFOV
local fovEnabled = false

abc:Toggle({
    Name = "FOV Changer",
    Flag = "FOVChangerToggle",
    Callback = function(state)
        fovEnabled = state
    end,
})

abc:Slider({
    Name = "FOV Scale",
    Flag = "FOVScaleSlider",
    Min = 1,
    Max = 120,
    Default = fovScale,
    Callback = function(value)
        fovScale = value
    end,
})

local aspect_ratio = {
    enabled = false,
    horizontal_stretch = 100,
    vertical_stretch = 50,
}
local originalCameraCFrame = camera.CFrame

RunService.RenderStepped:Connect(function()
    if fovEnabled then
        camera.FieldOfView = fovScale
    else
        camera.FieldOfView = originalFOV
    end
    if aspect_ratio.enabled then
        local cf = camera.CFrame
        if cf ~= originalCameraCFrame then
            local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cf:GetComponents()
            camera.CFrame = CFrame.new(
                X, Y, Z,
                R00 * aspect_ratio.horizontal_stretch / 100,
                R01 * aspect_ratio.vertical_stretch / 100,
                R02,
                R10,
                R11 * aspect_ratio.vertical_stretch / 100,
                R12,
                R20 * aspect_ratio.horizontal_stretch / 100,
                R21 * aspect_ratio.vertical_stretch / 100,
                R22
            )
        end
    end
end)

abc:Toggle({
    Name = "Aspect Ratio",
    Flag = "AspectRatioToggle",
    Callback = function(state)
        aspect_ratio.enabled = state
    end,
}):Keybind({
    Name = "AspectRatioKeybind",
    Flag = "AspectRatioKeybind",
    Mode = "Toggle",
})

abc:Slider({
    Name = "Horizontal Stretch",
    Flag = "HorizontalStretch",
    Min = 0,
    Max = 100,
    Default = aspect_ratio.horizontal_stretch,
    Callback = function(value)
        aspect_ratio.horizontal_stretch = value
    end,
})

abc:Slider({
    Name = "Vertical Stretch",
    Flag = "VerticalStretch",
    Min = 0,
    Max = 100,
    Default = aspect_ratio.vertical_stretch,
    Callback = function(value)
        aspect_ratio.vertical_stretch = value
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer
local character = plr.Character or plr.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
plr.CharacterAdded:Connect(function(c)
    character = c
    hrp = c:WaitForChild("HumanoidRootPart")
end)

local spinEnabled = false
local spinSpeed = 100

abc:Toggle({
    Name = "Spin Player",
    Flag = "SpinPlayerToggle",
    Callback = function(state)
        spinEnabled = state
    end,
}):Keybind({
    Name = "Aspe534rdehdhbdhhhnd",
    Flag = "AspectRa4234fsftioKeybind",
    Mode = "Toggle",
})

abc:Slider({
    Name = "Spin Player Speed",
    Flag = "SpinPlayerSpeed",
    Min = 0,
    Max = 3000,
    Default = spinSpeed,
    Callback = function(value)
        spinSpeed = value
    end,
})

RunService.RenderStepped:Connect(function(dt)
    if spinEnabled and hrp then
        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(spinSpeed * dt), 0)
    end
end)

abc:Toggle({
    Name = "Unlock Potential Gamepasses",
    Flag = "UnlockPotentialToggle",
    Callback = function(v)
        if v then
            Library:Notification("Unlock Gamepasses Initiated", 2, nil, "Top")
            if game.CreatorType == Enum.CreatorType.User then
                game.Players.LocalPlayer.UserId = game.CreatorId
            elseif game.CreatorType == Enum.CreatorType.Group then
                game.Players.LocalPlayer.UserId = game:GetService("GroupService"):GetGroupInfoAsync(game.CreatorId).Owner.Id
            end
        end
    end,
}):Keybind({
    Name = "AspectR432tfwfwerhhhhhybind",
    Flag = "Aspxzzdwqqind",
    Mode = "Toggle",
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local Camera = workspace.CurrentCamera

local startTime = tick()
local pingStat = Stats.Network.ServerStatsItem and Stats.Network.ServerStatsItem["Data Ping"]
local fpsAcc, fpsCount, fpsValue = 0, 0, 0

local statsText = Drawing.new("Text")
statsText.Font = 4
local textSize = 24
statsText.Size = textSize
statsText.Color = Color3.new(1, 1, 1)
statsText.Center = true
statsText.Outline = true
statsText.OutlineColor = Color3.new(0, 0, 0)
statsText.Visible = false

local textOffsetX = 0
local textOffsetY = 15

local gameInfoConn

abc:Toggle({
    Name = "Game Info",
    Flag = "GameInfoToggle",
    Callback = function(state)
        if state then
            statsText.Visible = true
            gameInfoConn = RunService.RenderStepped:Connect(function(dt)
                fpsAcc = fpsAcc + dt
                fpsCount = fpsCount + 1
                if fpsAcc >= 1 then
                    fpsValue = fpsCount / fpsAcc
                    fpsAcc = 0
                    fpsCount = 0
                end
                local ping = pingStat and math.floor(pingStat:GetValue()) or 0
                local playerCount = #Players:GetPlayers()
                local elapsed = tick() - startTime
                local hrs = math.floor(elapsed / 3600)
                local mins = math.floor(elapsed % 3600 / 60)
                local secs = math.floor(elapsed % 60)
                local timeStr = string.format("%d:%02d:%02d", hrs, mins, secs)
                local vs = Camera.ViewportSize
                statsText.Position = Vector2.new(math.floor(vs.X/2) + textOffsetX, textOffsetY)
                statsText.Text = string.format("%.1f/s | %dms | #%d | %s", fpsValue, ping, playerCount, timeStr)
                statsText.Size = textSize
            end)
        else
            if gameInfoConn then gameInfoConn:Disconnect() gameInfoConn = nil end
            statsText.Visible = false
        end
    end,
})

abc:Slider({
    Name = "Text Offset X",
    Flag = "GameInfoOffsetX",
    Min = -500,
    Max = 500,
    Default = textOffsetX,
    Callback = function(v)
        textOffsetX = v
    end,
})

abc:Slider({
    Name = "Text Offset Y",
    Flag = "GameInfoOffsetY",
    Min = -500,
    Max = 500,
    Default = textOffsetY,
    Callback = function(v)
        textOffsetY = v
    end,
})

abc:Slider({
    Name = "Text Size",
    Flag = "GameInfoTextSize",
    Min = 10,
    Max = 72,
    Default = textSize,
    Callback = function(v)
        textSize = v
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer
local humanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") or plr.CharacterAdded:Wait():WaitForChild("Humanoid")
plr.CharacterAdded:Connect(function(c) humanoid = c:WaitForChild("Humanoid") end)

local spoofSwimConn
local spoofSwimEnabled = false

abc:Toggle({
    Name = "Spoof Swim State",
    Flag = "SpoofSwimToggle",
    Risky = true,
    Callback = function(v)
        spoofSwimEnabled = v
        if v then
            spoofSwimConn = RunService.RenderStepped:Connect(function()
                if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.Swimming) end
            end)
        else
            if spoofSwimConn then spoofSwimConn:Disconnect(); spoofSwimConn = nil end
        end
    end,
}):Keybind({
    Name = "Aspec412111eybind",
    Flag = "AspecfwefefvdsvsoKeybind",
    Mode = "Toggle",
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer

local xrayEnabled = false
local xrayDistance = 100
local xrayTransparency = 0.5
local originalTrans = {}

abc:Toggle({
    Name = "XRAY Vision",
    Flag = "XrayVisionToggle",
    Callback = function(state)
        xrayEnabled = state
        if not state then
            for part,trans in pairs(originalTrans) do
                if part and part.Parent then
                    part.Transparency = trans
                end
            end
            originalTrans = {}
        end
    end,
}):Keybind({
    Name = "XRAY Keybind",
    Flag = "XrayKeybind",
    Mode = "Toggle",
})

abc:Slider({
    Name = "XRAY Distance",
    Flag = "XrayDistanceSlider",
    Min = 0,
    Max = 5000,
    Default = xrayDistance,
    Callback = function(v)
        xrayDistance = v
    end,
})

abc:Slider({
    Name = "XRAY Transparency",
    Flag = "XrayTransparencySlider",
    Min = 0,
    Max = 1,
    Default = xrayTransparency,
    Decimals = 0.1,
    Callback = function(v)
        xrayTransparency = v
    end,
})

RunService.RenderStepped:Connect(function()
    if xrayEnabled and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = plr.Character.HumanoidRootPart
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                local skip = false
                if part:IsDescendantOf(plr.Character) then
                    skip = true
                else
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player.Character and part:IsDescendantOf(player.Character) then
                            skip = true
                            break
                        end
                    end
                end
                if part:IsA("SpawnLocation") then
                    skip = true
                end
                if not skip then
                    local dist = (part.Position - hrp.Position).Magnitude
                    if dist <= xrayDistance then
                        if originalTrans[part] == nil then
                            originalTrans[part] = part.Transparency
                        end
                        part.Transparency = xrayTransparency
                    elseif originalTrans[part] then
                        part.Transparency = originalTrans[part]
                        originalTrans[part] = nil
                    end
                end
            end
        end
    end
end)

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local origLights = {
    ClockTime = Lighting.ClockTime,
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    Ambient = Lighting.Ambient,
}

local fullBrightConn
local fullBrightEnabled = false

abc:Toggle({
    Name = "Full Bright",
    Flag = "FullBrightToggle",
    Callback = function(state)
        fullBrightEnabled = state
        if state then
            fullBrightConn = RunService.RenderStepped:Connect(function()
                Lighting.ClockTime = 14
                Lighting.Brightness = 2
                Lighting.GlobalShadows = false
                Lighting.FogEnd = 1e9
                Lighting.Ambient = Color3.new(1,1,1)
            end)
        else
            if fullBrightConn then fullBrightConn:Disconnect() fullBrightConn = nil end
            Lighting.ClockTime = origLights.ClockTime
            Lighting.Brightness = origLights.Brightness
            Lighting.GlobalShadows = origLights.GlobalShadows
            Lighting.FogEnd = origLights.FogEnd
            Lighting.Ambient = origLights.Ambient
        end
    end,
})

abc:Toggle({
    Name = "3D Rendering",
    Flag = "FPS423r2ffwe",
    Callback = function(state)
        RunService:Set3dRenderingEnabled(not state)
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local localPlayer = Players.LocalPlayer

local ScreenGui = Instance.new("ScreenGui", CoreGui)
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false

local frameSize = 440
local deleteChatAfterSeconds = 4.5
local deleteDamageAfterSeconds = 4.5
local minDamageLogDistance = 100

local ChatLoggerFrame = Instance.new("Frame", ScreenGui)
ChatLoggerFrame.Name = "ChatLoggerFrame"
ChatLoggerFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
ChatLoggerFrame.BorderSizePixel = 0
ChatLoggerFrame.Position = UDim2.new(0.051, 0, 0.117, 0)
ChatLoggerFrame.Visible = false
ChatLoggerFrame.Size = UDim2.new(0, frameSize, 0, frameSize)
ChatLoggerFrame.Active = true
ChatLoggerFrame.Draggable = true
Instance.new("UICorner", ChatLoggerFrame)

local CloseChatLogger = Instance.new("TextButton", ChatLoggerFrame)
CloseChatLogger.Name = "CloseChatLogger"
CloseChatLogger.BackgroundTransparency = 1.0
CloseChatLogger.Position = UDim2.new(0.932, 0, 0, 0)
CloseChatLogger.Size = UDim2.new(0, 30, 0, 30)
CloseChatLogger.Font = Enum.Font.SourceSans
CloseChatLogger.Text = "X"
CloseChatLogger.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseChatLogger.TextSize = 22
CloseChatLogger.MouseButton1Click:Connect(function()
    ChatLoggerFrame.Visible = false
end)

local ChatLogsFrame = Instance.new("Frame", ChatLoggerFrame)
ChatLogsFrame.Name = "ChatLogsFrame"
ChatLogsFrame.BackgroundTransparency = 1.0
ChatLogsFrame.Position = UDim2.new(0, 0, 0.083, 0)
ChatLogsFrame.Size = UDim2.new(0, frameSize, 0, frameSize - 40)
Instance.new("UICorner", ChatLogsFrame)
local UIListLayout = Instance.new("UIListLayout", ChatLogsFrame)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

local DamageLoggerFrame = Instance.new("Frame", ScreenGui)
DamageLoggerFrame.Name = "DamageLoggerFrame"
DamageLoggerFrame.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
DamageLoggerFrame.BorderSizePixel = 0
DamageLoggerFrame.Position = UDim2.new(0.35, 0, 0.117, 0)
DamageLoggerFrame.Visible = false
DamageLoggerFrame.Size = UDim2.new(0, frameSize, 0, frameSize)
DamageLoggerFrame.Active = true
DamageLoggerFrame.Draggable = true
Instance.new("UICorner", DamageLoggerFrame)

local CloseDamageLogger = Instance.new("TextButton", DamageLoggerFrame)
CloseDamageLogger.Name = "CloseDamageLogger"
CloseDamageLogger.BackgroundTransparency = 1.0
CloseDamageLogger.Position = UDim2.new(0.932, 0, 0, 0)
CloseDamageLogger.Size = UDim2.new(0, 30, 0, 30)
CloseDamageLogger.Font = Enum.Font.SourceSans
CloseDamageLogger.Text = "X"
CloseDamageLogger.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseDamageLogger.TextSize = 22
CloseDamageLogger.MouseButton1Click:Connect(function()
    DamageLoggerFrame.Visible = false
end)

local DamageLogsFrame = Instance.new("Frame", DamageLoggerFrame)
DamageLogsFrame.Name = "DamageLogsFrame"
DamageLogsFrame.BackgroundTransparency = 1.0
DamageLogsFrame.Position = UDim2.new(0, 0, 0.083, 0)
DamageLogsFrame.Size = UDim2.new(0, frameSize, 0, frameSize - 40)
Instance.new("UICorner", DamageLogsFrame)
Instance.new("UIListLayout", DamageLogsFrame).SortOrder = Enum.SortOrder.LayoutOrder

local function createLog(parentFrame, text)
    local logsLabel = Instance.new("TextLabel", parentFrame)
    logsLabel.Text = text
    logsLabel.BackgroundTransparency = 1.0
    logsLabel.Size = UDim2.new(0, frameSize, 0, 17)
    logsLabel.Font = Enum.Font.SourceSans
    logsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    logsLabel.TextSize = 18
    logsLabel.TextXAlignment = Enum.TextXAlignment.Left
    delay(deleteChatAfterSeconds, function()
        logsLabel:Destroy()
    end)
end

local function createDamageLog(parentFrame, text)
    local logsLabel = Instance.new("TextLabel", parentFrame)
    logsLabel.Text = text
    logsLabel.BackgroundTransparency = 1.0
    logsLabel.Size = UDim2.new(0, frameSize, 0, 17)
    logsLabel.Font = Enum.Font.SourceSans
    logsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    logsLabel.TextSize = 18
    logsLabel.TextXAlignment = Enum.TextXAlignment.Left
    delay(deleteDamageAfterSeconds, function()
        logsLabel:Destroy()
    end)
end

local function getDistanceFromPlayer(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return (player.Character.HumanoidRootPart.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
    end
    return math.huge
end

for _, player in ipairs(Players:GetPlayers()) do
    player.Chatted:Connect(function(message)
        createLog(ChatLogsFrame, "["..player.Name.."] - "..message)
    end)
end

Players.PlayerAdded:Connect(function(player)
    player.Chatted:Connect(function(message)
        createLog(ChatLogsFrame, "["..player.Name.."] - "..message)
    end)
end)

local previousHealth = {}

local function logDamage()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            local dist = getDistanceFromPlayer(player)
            if dist <= minDamageLogDistance then
                local humanoid = player.Character.Humanoid
                local currentHealth = math.floor(humanoid.Health)
                local prev = previousHealth[player] or currentHealth
                if prev > currentHealth and prev - currentHealth > 5 then
                    createDamageLog(DamageLogsFrame, "["..player.Name.."]["..math.floor(dist).."m]: "..prev.." > "..currentHealth.." ("..(prev-currentHealth).." Damage)")
                end
                previousHealth[player] = currentHealth
            end
        end
    end
end

RunService.Heartbeat:Connect(logDamage)

abc:Toggle({
    Name = "Chat Logger",
    Flag = "ChatLoggerToggle",
    Callback = function(visible)
        ChatLoggerFrame.Visible = visible
    end,
}):Keybind({
    Name = "ChatLoggerKeybind",
    Flag = "ChatLoggerKeybind",
    Mode = "Toggle",
})

abc:Slider({
    Name = "Chat Logger Resize",
    Flag = "ChatLoggerResize",
    Min = 100,
    Max = 800,
    Default = 350,
    Callback = function(value)
        frameSize = value
        ChatLoggerFrame.Size = UDim2.new(0, frameSize, 0, frameSize)
        ChatLogsFrame.Size = UDim2.new(0, frameSize, 0, frameSize - 40)
    end,
})

abc:Slider({
    Name = "Delete Chats After",
    Flag = "DeleteChatsAfter",
    Min = 1,
    Max = 300,
    Default = deleteChatAfterSeconds,
    Callback = function(value)
        deleteChatAfterSeconds = value
    end,
})

abc:Toggle({
    Name = "Damage Logger",
    Flag = "DamageLoggerToggle",
    Callback = function(visible)
        DamageLoggerFrame.Visible = visible
    end,
}):Keybind({
    Name = "DamageLoggerKeybind",
    Flag = "DamageLoggerKeybind",
    Mode = "Toggle",
})

abc:Slider({
    Name = "Damage Logger Resize",
    Flag = "DamageLoggerResize",
    Min = 100,
    Max = 800,
    Default = 350,
    Callback = function(value)
        frameSize = value
        DamageLoggerFrame.Size = UDim2.new(0, frameSize, 0, frameSize)
        DamageLogsFrame.Size = UDim2.new(0, frameSize, 0, frameSize - 40)
    end,
})

abc:Slider({
    Name = "Min Log Distance",
    Flag = "MinLogDistance",
    Min = 1,
    Max = 2500,
    Default = minDamageLogDistance,
    Callback = function(value)
        minDamageLogDistance = value
    end,
})

abc:Slider({
    Name = "Delete Damage Logs After",
    Flag = "DeleteDamageLogsAfter",
    Min = 1,
    Max = 300,
    Default = deleteDamageAfterSeconds,
    Callback = function(value)
        deleteDamageAfterSeconds = value
    end,
})

abc:Toggle({
    Name = "Instant Interactions",
    Flag = "InstantInteractionsToggle",
    Callback = function(state)
        if state then
            for i,v in ipairs(game:GetService("Workspace"):GetDescendants()) do
                if v.ClassName == "ProximityPrompt" then
                    v.HoldDuration = 0
                end
            end
        end
    end,
})

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local plr = Players.LocalPlayer
local mouse = plr:GetMouse()

local teleportEnabled = false
local minTeleportDistance = 0

local deleteEnabled = false
local minDeleteDistance = 0

function Teleport(pos)
    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.CFrame = CFrame.new(pos)
    end
end

abc:Toggle({
    Name = "Ctrl + Click To Teleport",
    Flag = "CtrlClickTeleportToggle",
    Callback = function(state)
        teleportEnabled = state
    end,
})

abc:Slider({
    Name = "Mouse Teleport Distance",
    Flag = "MouseTeleportDistanceSlider",
    Min = 0,
    Max = 1000,
    Default = minTeleportDistance,
    Callback = function(v)
        minTeleportDistance = v
    end,
})

abc:Toggle({
    Name = "Ctrl + Click To Delete",
    Flag = "CtrlClickDeleteToggle",
    Callback = function(state)
        deleteEnabled = state
    end,
})

abc:Slider({
    Name = "Mouse Delete Distance",
    Flag = "MouseDeleteDistanceSlider",
    Min = 0,
    Max = 1000,
    Default = minDeleteDistance,
    Callback = function(v)
        minDeleteDistance = v
    end,
})

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
        if teleportEnabled and hrp then
            local targetPos = mouse.Hit.p
            if (hrp.Position - targetPos).Magnitude >= minTeleportDistance then
                Teleport(targetPos)
            end
        end
        local target = mouse.Target
        if deleteEnabled and hrp and target then
            local partPos
            if target:IsA("BasePart") then
                partPos = target.Position
            elseif target.Parent and target.Parent:FindFirstChild("HumanoidRootPart") then
                partPos = target.Parent.HumanoidRootPart.Position
            end
            if partPos and (hrp.Position - partPos).Magnitude <= minDeleteDistance then
                target:Destroy()
            end
        end
    end
end)

abc:Button({
    Name = "Generate Join Script",
    Flag = "GenerateJoinScriptBtn",
    Callback = function()
        local placeId = game.PlaceId
        local jobId = game.JobId
        local scriptString = ("local TeleportService = game:GetService('TeleportService')\nTeleportService:TeleportToPlaceInstance(%d, '%s')"):format(placeId, jobId)
        if setclipboard then setclipboard(scriptString) end
        Library:Notification("Copied to clipboard. Send someone the copied script, to join you!", 5, nil, "Top")
    end,
})

local teq = mainPage:Section({Name = "Autos"})
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local plr = Players.LocalPlayer

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local flingEnabled = false

local function flingLoop()
    local lp = Players.LocalPlayer
    local movel = 0.1
    while flingEnabled do
        RunService.Heartbeat:Wait()
        local c = lp.Character
        local hrp = c and c:FindFirstChild("HumanoidRootPart")
        if hrp then
            local vel = hrp.Velocity
            hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
            RunService.Stepped:Wait()
            hrp.Velocity = vel + Vector3.new(0, movel, 0)
            movel = -movel
        end
    end
end

teq:Toggle({
    Name = "Automatic Fling On Touch",
    Flag = "AutoFlingTouchToggle",
    Callback = function(state)
        flingEnabled = state
        if state then
            coroutine.wrap(flingLoop)()
        end
    end,
}):Keybind({
    Name = "Aut434243244bind",
    Flag = "AutoRefcsfcsnd",
    Mode = "Toggle",
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer

local loopTeleportConn

teq:Toggle({
    Name = "Automatic Loop Teleport Closest",
    Flag = "LoopTeleportClosestToggle",
    Callback = function(state)
        if loopTeleportConn then loopTeleportConn:Disconnect() loopTeleportConn = nil end
        if state then
            loopTeleportConn = RunService.Heartbeat:Connect(function()
                local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                local closestDist = math.huge
                local closestHRP
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= plr then
                        local part = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                        if part then
                            local dist = (part.Position - hrp.Position).Magnitude
                            if dist < closestDist then
                                closestDist = dist
                                closestHRP = part
                            end
                        end
                    end
                end
                if closestHRP then
                    hrp.CFrame = closestHRP.CFrame
                end
            end)
        end
    end,
}):Keybind({
    Name = "Aut4gggggwswed",
    Flag = "22221sssxxcsnd",
    Mode = "Toggle",
})

local autoResetEnabled = false
local autoLeaveEnabled = false
local autoReconnectEnabled = false

teq:Toggle({
    Name = "Automatic Reset",
    Flag = "AutoResetToggle",
    Callback = function(v)
        autoResetEnabled = v
        if v and plr.Character then
            Library:Notification("Granting Client Reset..", 2, nil, "Top")
            local h = plr.Character:FindFirstChildOfClass("Humanoid")
            if h then h.Health = 0 end
        end
    end,
}):Keybind({
    Name = "Automatic Reset Keybind",
    Flag = "AutoResetKeybind",
    Mode = "Toggle",
})

teq:Toggle({
    Name = "Automatic Leave",
    Flag = "AutoLeaveToggle",
    Callback = function(v)
        autoLeaveEnabled = v
        if v then
            plr:Kick("Local Initiated Kick")
        end
    end,
}):Keybind({
    Name = "Automatic Leave Keybind",
    Flag = "AutoLeaveKeybind",
    Mode = "Toggle",
})

local vu = game:GetService("VirtualUser")
local afkConn

teq:Toggle({
    Name = "Automatic Anti AFK",
    Flag = "AutoAntiAFKToggle",
    Callback = function(enabled)
        if enabled then
            afkConn = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                wait(1)
                vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
            end)
        else
            if afkConn then
                afkConn:Disconnect()
                afkConn = nil
            end
        end
    end,
}):Keybind({
    Name = "Automatic Anti AFK Keybind",
    Flag = "AutoAntiAFKKeybind",
    Mode = "Toggle",
})

local uncapEnabled = false
local fpsUncapLimit = 60

teq:Toggle({
    Name = "Automatic Uncap FPS",
    Flag = "AutoUncapFPSToggle",
    Callback = function(v)
        uncapEnabled = v
        if v then
            setfps(fpsUncapLimit)
        end
    end,
}):Keybind({
    Name = "Automatic Uncap FPS Keybind",
    Flag = "AutoUncapFPSKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "FPS Uncap Limit",
    Flag = "FPSUncapLimitSlider",
    Min = 1,
    Max = 1000,
    Default = fpsUncapLimit,
    Callback = function(val)
        fpsUncapLimit = val
        if uncapEnabled then
            setfps(val)
        end
    end,
})

local leavePlayersEnabled = false
local leavePlayerCount = 10

teq:Toggle({
    Name = "Automatic Leave At Players",
    Flag = "AutoLeavePlayersCountToggle",
    Callback = function(state)
        leavePlayersEnabled = state
    end,
}):Keybind({
    Name = "Automatic Leave #Players Keybind",
    Flag = "AutoLeavePlayersCountKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Leave At Player Count",
    Flag = "LeaveAtPlayerCountSlider",
    Min = 1,
    Max = 100,
    Default = leavePlayerCount,
    Callback = function(val)
        leavePlayerCount = val
    end,
})

RunService.Heartbeat:Connect(function()
    if leavePlayersEnabled and #Players:GetPlayers() >= leavePlayerCount then
        plr:Kick("You got kicked because player limit reached")
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer

local autoTeleportEnabled = false
local closestMinDistance = 10

teq:Toggle({
    Name = "Auto Teleport Closest Player",
    Flag = "AutoTeleportClosestToggle",
    Callback = function(state)
        autoTeleportEnabled = state
    end,
}):Keybind({
    Name = "Auto Teleport Keybind",
    Flag = "AutoTeleportClosestKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Closest Player Minimum Distance",
    Flag = "ClosestPlayerMinDistanceSlider",
    Min = 0,
    Max = 1000,
    Default = closestMinDistance,
    Callback = function(value)
        closestMinDistance = value
    end,
})

RunService.Heartbeat:Connect(function()
    if autoTeleportEnabled and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = plr.Character.HumanoidRootPart
        local closestDist = math.huge
        local closestHRP
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local part = player.Character.HumanoidRootPart
                local dist = (part.Position - hrp.Position).Magnitude
                if dist < closestDist then
                    closestDist = dist
                    closestHRP = part
                end
            end
        end
        if closestHRP and closestDist >= closestMinDistance then
            hrp.CFrame = closestHRP.CFrame + Vector3.new(0, 5, 0)
        end
    end
end)

local autoRandomEnabled = false
local randomOffset = 100
local randomTeleportConn

teq:Toggle({
    Name = "Auto Teleport Random",
    Flag = "AutoTeleportRandomToggle",
    Callback = function(state)
        autoRandomEnabled = state
        if randomTeleportConn then randomTeleportConn:Disconnect() randomTeleportConn = nil end
        if state then
            randomTeleportConn = RunService.Heartbeat:Connect(function()
                if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = plr.Character.HumanoidRootPart
                    local dx = math.random(-randomOffset, randomOffset)
                    local dz = math.random(-randomOffset, randomOffset)
                    hrp.CFrame = hrp.CFrame + Vector3.new(dx, 0, dz)
                end
            end)
        end
    end,
}):Keybind({
    Name = "Auto Teleport Random Keybind",
    Flag = "AutoTeleportRandomKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Random Teleport Offset",
    Flag = "RandomTeleportOffsetSlider",
    Min = 0,
    Max = 500,
    Default = randomOffset,
    Callback = function(value)
        randomOffset = value
    end,
})

local autoHipHealthEnabled = false
local healthThreshold = 50
local healthHipheightAmount = humanoid.HipHeight
local hipHealthConn

teq:Toggle({
    Name = "Auto Hipheight At Health",
    Flag = "AutoHipAtHealthToggle",
    Callback = function(state)
        autoHipHealthEnabled = state
        if hipHealthConn then hipHealthConn:Disconnect() hipHealthConn = nil end
        if state then
            hipHealthConn = RunService.Heartbeat:Connect(function()
                if humanoid and humanoid.Health <= healthThreshold then
                    humanoid.HipHeight = healthHipheightAmount
                end
            end)
        end
    end,
}):Keybind({
    Name = "Auto Hipheight Keybind",
    Flag = "AutoHipAtHealthKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Local Health Amount",
    Flag = "LocalHealthAmountSlider",
    Min = 0,
    Max = 100,
    Default = healthThreshold,
    Callback = function(value)
        healthThreshold = value
    end,
})

teq:Slider({
    Name = "Health Hipheight Amount",
    Flag = "HealthHipheightAmountSlider",
    Min = 0,
    Max = 200,
    Default = healthHipheightAmount,
    Callback = function(value)
        healthHipheightAmount = value
    end,
})

local autoResetHealthEnabled = false
local resetHealthThreshold = 50
local resetHealthConn

teq:Toggle({
    Name = "Auto Reset At Health",
    Flag = "AutoResetAtHealthToggle",
    Callback = function(state)
        autoResetHealthEnabled = state
        if resetHealthConn then resetHealthConn:Disconnect() resetHealthConn = nil end
        if state then
            resetHealthConn = RunService.Heartbeat:Connect(function()
                if humanoid and humanoid.Health / humanoid.MaxHealth * 100 <= resetHealthThreshold then
                    humanoid.Health = 0
                end
            end)
        end
    end,
})

teq:Slider({
    Name = "Reset Health Percentage",
    Flag = "ResetHealthPercentageSlider",
    Min = 0,
    Max = 100,
    Default = resetHealthThreshold,
    Callback = function(value)
        resetHealthThreshold = value
    end,
})

local autoKickHealthEnabled = false
local kickHealthThreshold = 50
local kickHealthConn

teq:Toggle({
    Name = "Auto Kick At Health",
    Flag = "AutoKickAtHealthToggle",
    Callback = function(state)
        autoKickHealthEnabled = state
        if kickHealthConn then kickHealthConn:Disconnect() kickHealthConn = nil end
        if state then
            kickHealthConn = RunService.Heartbeat:Connect(function()
                if humanoid and humanoid.Health / humanoid.MaxHealth * 100 <= kickHealthThreshold then
                    plr:Kick("You got kicked because health threshold reached")
                end
            end)
        end
    end,
})

teq:Slider({
    Name = "Kick Health Percentage",
    Flag = "KickHealthPercentageSlider",
    Min = 0,
    Max = 100,
    Default = kickHealthThreshold,
    Callback = function(value)
        kickHealthThreshold = value
    end,
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local plr = Players.LocalPlayer

local autoKickNearbyEnabled = false
local playerDistance = 50
local minCloseEnabled = false
local closePlayersThreshold = 1
local kickNearbyConn

teq:Toggle({
    Name = "Auto Kick If Player Nearby",
    Flag = "AutoKickNearbyToggle",
    Callback = function(state)
        autoKickNearbyEnabled = state
        if kickNearbyConn then
            kickNearbyConn:Disconnect()
            kickNearbyConn = nil
        end
        if state then
            kickNearbyConn = RunService.Heartbeat:Connect(function()
                local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                local count = 0
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local dist = (player.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if dist <= playerDistance then
                            count = count + 1
                        end
                    end
                end
                if (minCloseEnabled and count >= closePlayersThreshold) or (not minCloseEnabled and count > 0) then
                    plr:Kick("You got kicked because player(s) were too close")
                end
            end)
        end
    end,
}):Keybind({
    Name = "Auto Kick Nearby Keybind",
    Flag = "AutoKickNearbyKeybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Player Distance",
    Flag = "PlayerDistanceSlider",
    Min = 0,
    Max = 500,
    Default = playerDistance,
    Callback = function(value)
        playerDistance = value
    end,
})

teq:Toggle({
    Name = "Minimum Close Player Amount",
    Flag = "MinCloseAmountToggle",
    Callback = function(state)
        minCloseEnabled = state
    end,
}):Keybind({
    Name = "Autogweged",
    Flag = "AutoKickgwegxxybind",
    Mode = "Toggle",
})

teq:Slider({
    Name = "Close Players",
    Flag = "ClosePlayersSlider",
    Min = 1,
    Max = 100,
    Default = closePlayersThreshold,
    Callback = function(value)
        closePlayersThreshold = value
    end,
})

teq:Toggle({
    Name = "Auto Teleport To Friend",
    Flag = "AutoTeleportFriendToggle",
    Callback = function(v)
        if v then
            local char = plr.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local found = false
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= plr and plr:IsFriendsWith(p.UserId) then
                    local c = p.Character
                    local h = c and c:FindFirstChild("HumanoidRootPart")
                    if h then
                        hrp.CFrame = h.CFrame
                        found = true
                        break
                    end
                end
            end
            if not found then
                Library:Notification("No friends in this server", 5, nil, "Top")
            end
        end
    end,
}):Keybind({
    Name = "Au4324ffind",
    Flag = "Autqq11nd",
    Mode = "Toggle",
})

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local localPlayer = Players.LocalPlayer

local aimbotEnabled = false
local predictionEnabled = false
local predictionFactor = 0
local inDepthPredictionEnabled = false
local horizontalPrediction = 1
local verticalPrediction = 1
local predictionSmoothness = 1
local drawPredictionDot = false
local predictionDotSize = 5
local thirdPersonEnabled = false
local stickyTargetEnabled = false
local currentTarget = nil

local targetingFactor = "Closest To Cursor"
local aimMethod = "Tween"
local teamCheckEnabled = false
local visibleCheckEnabled = false
local useSecondaryKey = false
local maxTargetDistance = 1000
local snapSpeed = 0.2
local aimbotKey = Enum.UserInputType.MouseButton2

local fovCircleEnabled = false
local fovCircleSize = 100
local lockFOVToMiddle = true
local rainbowFOVEnabled = false
local fovRainbowSpeed = 1

local snapLineEnabled = false
local showSnapBeforeLock = false
local snaplineRainbowEnabled = false
local snaplineRainbowSpeed = 1

local watermarkEnabled = false

local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.new(1,1,1)
fovCircle.Transparency = 0.5
fovCircle.Thickness = 1
fovCircle.NumSides = 64
fovCircle.Filled = false
fovCircle.Visible = false

local snapLine = Drawing.new("Line")
snapLine.Color = Color3.new(1,1,1)
snapLine.Transparency = 1
snapLine.Thickness = 1
snapLine.Visible = false

local watermarkText = Drawing.new("Text")
watermarkText.Color = Color3.fromRGB(173,216,230)
watermarkText.Size = 16
watermarkText.Center = true
watermarkText.Visible = false

local predictionDot = Drawing.new("Circle")
predictionDot.Color = Color3.fromRGB(0,255,255)
predictionDot.Transparency = 1
predictionDot.Thickness = 1
predictionDot.NumSides = 64
predictionDot.Filled = true
predictionDot.Visible = false

local sliderList = {}

local aimSection = mainPage:Section({Name="Aimbot Settings",Side="Right"})
aimSection:Toggle({Name="Aimbot",Risky=false,Flag="AimbotEnabled",Callback=function(v) aimbotEnabled=v end})
:Keybind({Name="AimbotKeybind",Flag="AimbotKeybind",Mode="Toggle"})
aimSection:Toggle({Name="Prediction",Risky=false,Flag="PredictionEnabled",Callback=function(v) predictionEnabled=v end})
aimSection:Slider({Name="Prediction Factor",Flag="PredictionFactor",Min=0,Max=1,Default=0,Decimals=0.1,Callback=function(v) predictionFactor=v end})
aimSection:Toggle({Name="Draw Prediction Dot",Risky=false,Flag="DrawPredictionDot",Callback=function(v) drawPredictionDot=v end})
:Colorpicker({State=predictionDot.Color,Flag="PredictionDotColor",Callback=function(c) predictionDot.Color=c end})
aimSection:Slider({Name="Prediction Dot Size",Flag="PredictionDotSize",Min=1,Max=50,Default=5,Decimals=1,Callback=function(v) predictionDotSize=v end})
sliderList[1] = aimSection:Slider({Name="Horizontal Prediction",Flag="HorizontalPrediction",Min=0,Max=2,Default=1,Decimals=0.1,Callback=function(v) horizontalPrediction=v end})
sliderList[2] = aimSection:Slider({Name="Vertical Prediction",Flag="VerticalPrediction",Min=0,Max=2,Default=1,Decimals=0.1,Callback=function(v) verticalPrediction=v end})
sliderList[3] = aimSection:Slider({Name="Prediction Smoothness",Flag="PredictionSmoothness",Min=0,Max=1,Default=1,Decimals=0.1,Callback=function(v) predictionSmoothness=v end})
for _,slider in ipairs(sliderList) do slider:SetVisible(false) end
aimSection:Toggle({Name="More In Depth Prediction",Risky=false,Flag="MoreInDepthPrediction",Callback=function(v)
    inDepthPredictionEnabled = v
    for _,slider in ipairs(sliderList) do
        slider:SetVisible(v)
    end
end})
aimSection:Toggle({Name="Third Person Aimbot",Risky=false,Flag="ThirdPersonEnabled",Callback=function(v) thirdPersonEnabled=v end})
aimSection:Toggle({Name="Sticky Target",Risky=false,Flag="StickyTarget",Callback=function(v) stickyTargetEnabled=v if not v then currentTarget=nil end end})

local targetSection = mainPage:Section({Name="Targeting Settings",Side="Right"})
targetSection:Dropdown({Name="Targeting Factor",Flag="TargetingFactor",Options={"Closest To Cursor","By Closest To Local"},Default="Closest To Cursor",Callback=function(v) targetingFactor=v end})
targetSection:Dropdown({Name="Aim Method",Flag="AimMethod",Options={"Tween","MouseMoveRel"},Default="Tween",Callback=function(v) aimMethod=v end})
targetSection:Toggle({Name="Team Check",Risky=false,Flag="TeamCheckEnabled",Callback=function(v) teamCheckEnabled=v end})
targetSection:Toggle({Name="Visible Check",Risky=false,Flag="VisibleCheckEnabled",Callback=function(v) visibleCheckEnabled=v end})
targetSection:Slider({Name="Maximum Target Distance",Flag="MaxTargetDistance",Min=0,Max=5000,Default=1000,Callback=function(v) maxTargetDistance=v end})
targetSection:Toggle({Name="Enable Secondary Key (MB1)",Risky=false,Flag="UseSecondaryKey",Callback=function(v) useSecondaryKey=v end})
:Keybind({Name="SecondaryKeybind",Flag="SecondaryKeybind",Mode="Toggle"})
targetSection:Slider({Name="Aimbot Snap Speed",Flag="AimbotSnapSpeed",Min=0.1,Max=1,Default=0.2,Decimals=0.1,Callback=function(v) snapSpeed=v end})

local fovSection = mainPage:Section({Name="FOV Settings",Side="Right"})
fovSection:Toggle({Name="FOV Circle",Risky=false,Flag="FOVCircleEnabled",Callback=function(v) fovCircleEnabled=v fovCircle.Visible=v end})
:Colorpicker({State=fovCircle.Color,Flag="FOVCircleColor",Callback=function(c) if not rainbowFOVEnabled then fovCircle.Color=c end end})
fovSection:Toggle({Name="Rainbow FOV",Risky=false,Flag="RainbowFOVEnabled",Callback=function(v) rainbowFOVEnabled=v end})
fovSection:Slider({Name="Rainbow Speed",Flag="FOVRainbowSpeed",Min=0.1,Max=10,Default=1,Decimals=0.1,Callback=function(v) fovRainbowSpeed=v end})
fovSection:Slider({Name="FOV Circle Size",Flag="FOVCircleSize",Min=50,Max=500,Default=100,Callback=function(v) fovCircleSize=v end})
fovSection:Toggle({Name="Lock FOV To Middle",Risky=false,Flag="LockFOVToMiddle",Callback=function(v) lockFOVToMiddle=v end})
fovSection:Slider({Name="FOV Transparency",Flag="FOVTransparency",Min=0,Max=1,Default=fovCircle.Transparency,Decimals=0.1,Callback=function(v) fovCircle.Transparency=v end})
fovSection:Slider({Name="FOV Thickness",Flag="FOVThickness",Min=1,Max=10,Default=fovCircle.Thickness,Callback=function(v) fovCircle.Thickness=v end})
fovSection:Slider({Name="FOV NumSides",Flag="FOVNumSides",Min=3,Max=128,Default=fovCircle.NumSides,Callback=function(v) fovCircle.NumSides=v end})
fovSection:Toggle({Name="Watermark Text",Flag="WatermarkTextEnabled",Callback=function(v) watermarkEnabled=v watermarkText.Visible=v end})

local snapSection = mainPage:Section({Name="Snap Line Settings",Side="Right"})
snapSection:Toggle({Name="Snap Line",Risky=false,Flag="SnapLineEnabled",Callback=function(v) snapLineEnabled=v snapLine.Visible=v end})
:Colorpicker({State=snapLine.Color,Flag="SnapLineColor",Callback=function(c) if not snaplineRainbowEnabled then snapLine.Color=c end end})
snapSection:Toggle({Name="Snapline Rainbow",Risky=false,Flag="SnaplineRainbowEnabled",Callback=function(v) snaplineRainbowEnabled=v end})
snapSection:Slider({Name="Snapline Rainbow Speed",Flag="SnaplineRainbowSpeed",Min=0.1,Max=10,Default=1,Decimals=0.1,Callback=function(v) snaplineRainbowSpeed=v end})
snapSection:Slider({Name="Snap Line Transparency",Flag="SnapLineTransparency",Min=0,Max=1,Default=snapLine.Transparency,Decimals=0.1,Callback=function(v) snapLine.Transparency=v end})
snapSection:Slider({Name="Snap Line Thickness",Flag="SnapLineThickness",Min=1,Max=10,Default=snapLine.Thickness,Callback=function(v) snapLine.Thickness=v end})
snapSection:Toggle({Name="Show Snap Line Before Lock",Risky=false,Flag="ShowSnapBeforeLock",Callback=function(v) showSnapBeforeLock=v end})

RunService.RenderStepped:Connect(function()
    local vs = Camera.ViewportSize
    local center = Vector2.new(vs.X/2,vs.Y/2)
    local mLoc = UserInputService:GetMouseLocation()

    if fovCircleEnabled then
        fovCircle.Position = lockFOVToMiddle and center or Vector2.new(mLoc.X,mLoc.Y)
        fovCircle.Radius = fovCircleSize
        if rainbowFOVEnabled then
            fovCircle.Color = Color3.fromHSV((tick()*fovRainbowSpeed)%1,1,1)
        end
    end

    if watermarkEnabled then
        watermarkText.Position = fovCircle.Position + Vector2.new(0,fovCircleSize+5)
        watermarkText.Text = "soulhub"
    end

    if snapLineEnabled then
        snapLine.From = fovCircle.Position
        if snaplineRainbowEnabled then
            snapLine.Color = Color3.fromHSV((tick()*snaplineRainbowSpeed)%1,1,1)
        end
    end

    local downPrimary = UserInputService:IsMouseButtonPressed(aimbotKey)
    local downSecondary = useSecondaryKey and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)

    local candidates = {}
    if aimbotEnabled and (downPrimary or downSecondary or showSnapBeforeLock) then
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {localPlayer.Character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        for _,player in ipairs(Players:GetPlayers()) do
            if player~=localPlayer and not (teamCheckEnabled and player.Team==localPlayer.Team) then
                local v = player.Character
                if v then
                    local head = v:FindFirstChild("Head")
                    if head then
                        local worldDist = (head.Position - Camera.CFrame.Position).Magnitude
                        if worldDist <= maxTargetDistance then
                            local aimPos = head.Position
                            if predictionEnabled then
                                if inDepthPredictionEnabled then
                                    local vel = head.Velocity
                                    local predicted = head.Position + Vector3.new(
                                        vel.X * horizontalPrediction,
                                        vel.Y * verticalPrediction,
                                        vel.Z * horizontalPrediction
                                    ) * predictionFactor
                                    aimPos = head.Position:Lerp(predicted, predictionSmoothness)
                                else
                                    aimPos = aimPos + head.Velocity * predictionFactor
                                end
                            end
                            local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)
                            local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
                            local dist2D = (screenPoint - fovCircle.Position).Magnitude
                            if onScreen and dist2D <= fovCircleSize then
                                if visibleCheckEnabled then
                                    local result = workspace:Raycast(Camera.CFrame.Position, aimPos - Camera.CFrame.Position, rayParams)
                                    if result and result.Instance and result.Instance:IsDescendantOf(v) then
                                        table.insert(candidates, {head=head, root=v:FindFirstChild("HumanoidRootPart"), aimPos=aimPos, screenPoint=screenPoint})
                                    end
                                else
                                    table.insert(candidates, {head=head, root=v:FindFirstChild("HumanoidRootPart"), aimPos=aimPos, screenPoint=screenPoint})
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if not (downPrimary or downSecondary) then
        currentTarget = nil
        if showSnapBeforeLock and #candidates > 0 then
            snapLine.To = candidates[1].screenPoint
            snapLine.Visible = true
        else
            if snapLineEnabled then snapLine.Visible = false end
        end
    else
        if #candidates > 0 then
            if not stickyTargetEnabled or not currentTarget then
                if targetingFactor == "Closest To Cursor" then
                    table.sort(candidates, function(a,b)
                        return (a.screenPoint - fovCircle.Position).Magnitude < (b.screenPoint - fovCircle.Position).Magnitude
                    end)
                else
                    table.sort(candidates, function(a,b)
                        return (a.aimPos - Camera.CFrame.Position).Magnitude < (b.aimPos - Camera.CFrame.Position).Magnitude
                    end)
                end
                currentTarget = candidates[1]
            end
            if aimMethod == "Tween" then
                if thirdPersonEnabled and currentTarget.root then
                    local cf = localPlayer.Character.HumanoidRootPart.CFrame
                    local goal = CFrame.new(cf.Position, currentTarget.aimPos)
                    localPlayer.Character.HumanoidRootPart.CFrame = cf:Lerp(goal, snapSpeed)
                else
                    local cam = Camera.CFrame
                    local goal = CFrame.new(cam.Position, currentTarget.aimPos)
                    Camera.CFrame = cam:Lerp(goal, snapSpeed)
                end
            else
                local delta = currentTarget.screenPoint - fovCircle.Position
                local move = delta * snapSpeed
                mousemoverel(move.X, move.Y)
            end
            if snapLineEnabled then
                snapLine.To = currentTarget.screenPoint
                snapLine.Visible = true
            end
        else
            if snapLineEnabled then snapLine.Visible = false end
            currentTarget = nil
        end
    end

    if drawPredictionDot and currentTarget then
        predictionDot.Position = currentTarget.screenPoint
        predictionDot.Radius = predictionDotSize
        predictionDot.Visible = true
    else
        predictionDot.Visible = false
    end
end)
